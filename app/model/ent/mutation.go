// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/suisrc/zgo/app/model/ent/account"
	"github.com/suisrc/zgo/app/model/ent/predicate"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount = "Account"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	pid           *string
	account       *string
	account_typ   *string
	account_kid   *string
	password      *string
	password_salt *string
	password_type *string
	verify_secret *string
	verify_type   *string
	user_id       *int
	adduser_id    *int
	role_id       *int
	addrole_id    *int
	status        *int
	addstatus     *int
	description   *string
	oa2_token     *string
	oa2_expired   *time.Time
	oa2_fake      *string
	oa2_client    *int
	addoa2_client *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	string_1      *string
	string_2      *string
	string_3      *string
	number_1      *int
	addnumber_1   *int
	number_2      *int
	addnumber_2   *int
	number_3      *int
	addnumber_3   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Account, error)
	predicates    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPid sets the "pid" field.
func (m *AccountMutation) SetPid(s string) {
	m.pid = &s
}

// Pid returns the value of the "pid" field in the mutation.
func (m *AccountMutation) Pid() (r string, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// ResetPid resets all changes to the "pid" field.
func (m *AccountMutation) ResetPid() {
	m.pid = nil
}

// SetAccount sets the "account" field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
}

// SetAccountTyp sets the "account_typ" field.
func (m *AccountMutation) SetAccountTyp(s string) {
	m.account_typ = &s
}

// AccountTyp returns the value of the "account_typ" field in the mutation.
func (m *AccountMutation) AccountTyp() (r string, exists bool) {
	v := m.account_typ
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountTyp returns the old "account_typ" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountTyp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountTyp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountTyp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountTyp: %w", err)
	}
	return oldValue.AccountTyp, nil
}

// ResetAccountTyp resets all changes to the "account_typ" field.
func (m *AccountMutation) ResetAccountTyp() {
	m.account_typ = nil
}

// SetAccountKid sets the "account_kid" field.
func (m *AccountMutation) SetAccountKid(s string) {
	m.account_kid = &s
}

// AccountKid returns the value of the "account_kid" field in the mutation.
func (m *AccountMutation) AccountKid() (r string, exists bool) {
	v := m.account_kid
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountKid returns the old "account_kid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountKid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountKid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountKid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountKid: %w", err)
	}
	return oldValue.AccountKid, nil
}

// ResetAccountKid resets all changes to the "account_kid" field.
func (m *AccountMutation) ResetAccountKid() {
	m.account_kid = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordSalt sets the "password_salt" field.
func (m *AccountMutation) SetPasswordSalt(s string) {
	m.password_salt = &s
}

// PasswordSalt returns the value of the "password_salt" field in the mutation.
func (m *AccountMutation) PasswordSalt() (r string, exists bool) {
	v := m.password_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordSalt returns the old "password_salt" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordSalt: %w", err)
	}
	return oldValue.PasswordSalt, nil
}

// ResetPasswordSalt resets all changes to the "password_salt" field.
func (m *AccountMutation) ResetPasswordSalt() {
	m.password_salt = nil
}

// SetPasswordType sets the "password_type" field.
func (m *AccountMutation) SetPasswordType(s string) {
	m.password_type = &s
}

// PasswordType returns the value of the "password_type" field in the mutation.
func (m *AccountMutation) PasswordType() (r string, exists bool) {
	v := m.password_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordType returns the old "password_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordType: %w", err)
	}
	return oldValue.PasswordType, nil
}

// ResetPasswordType resets all changes to the "password_type" field.
func (m *AccountMutation) ResetPasswordType() {
	m.password_type = nil
}

// SetVerifySecret sets the "verify_secret" field.
func (m *AccountMutation) SetVerifySecret(s string) {
	m.verify_secret = &s
}

// VerifySecret returns the value of the "verify_secret" field in the mutation.
func (m *AccountMutation) VerifySecret() (r string, exists bool) {
	v := m.verify_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifySecret returns the old "verify_secret" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldVerifySecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVerifySecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVerifySecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifySecret: %w", err)
	}
	return oldValue.VerifySecret, nil
}

// ResetVerifySecret resets all changes to the "verify_secret" field.
func (m *AccountMutation) ResetVerifySecret() {
	m.verify_secret = nil
}

// SetVerifyType sets the "verify_type" field.
func (m *AccountMutation) SetVerifyType(s string) {
	m.verify_type = &s
}

// VerifyType returns the value of the "verify_type" field in the mutation.
func (m *AccountMutation) VerifyType() (r string, exists bool) {
	v := m.verify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyType returns the old "verify_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldVerifyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVerifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVerifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyType: %w", err)
	}
	return oldValue.VerifyType, nil
}

// ResetVerifyType resets all changes to the "verify_type" field.
func (m *AccountMutation) ResetVerifyType() {
	m.verify_type = nil
}

// SetUserID sets the "user_id" field.
func (m *AccountMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AccountMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *AccountMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AccountMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *AccountMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *AccountMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AccountMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AccountMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AccountMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
}

// SetOa2Token sets the "oa2_token" field.
func (m *AccountMutation) SetOa2Token(s string) {
	m.oa2_token = &s
}

// Oa2Token returns the value of the "oa2_token" field in the mutation.
func (m *AccountMutation) Oa2Token() (r string, exists bool) {
	v := m.oa2_token
	if v == nil {
		return
	}
	return *v, true
}

// OldOa2Token returns the old "oa2_token" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOa2Token(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOa2Token is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOa2Token requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOa2Token: %w", err)
	}
	return oldValue.Oa2Token, nil
}

// ResetOa2Token resets all changes to the "oa2_token" field.
func (m *AccountMutation) ResetOa2Token() {
	m.oa2_token = nil
}

// SetOa2Expired sets the "oa2_expired" field.
func (m *AccountMutation) SetOa2Expired(t time.Time) {
	m.oa2_expired = &t
}

// Oa2Expired returns the value of the "oa2_expired" field in the mutation.
func (m *AccountMutation) Oa2Expired() (r time.Time, exists bool) {
	v := m.oa2_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldOa2Expired returns the old "oa2_expired" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOa2Expired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOa2Expired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOa2Expired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOa2Expired: %w", err)
	}
	return oldValue.Oa2Expired, nil
}

// ResetOa2Expired resets all changes to the "oa2_expired" field.
func (m *AccountMutation) ResetOa2Expired() {
	m.oa2_expired = nil
}

// SetOa2Fake sets the "oa2_fake" field.
func (m *AccountMutation) SetOa2Fake(s string) {
	m.oa2_fake = &s
}

// Oa2Fake returns the value of the "oa2_fake" field in the mutation.
func (m *AccountMutation) Oa2Fake() (r string, exists bool) {
	v := m.oa2_fake
	if v == nil {
		return
	}
	return *v, true
}

// OldOa2Fake returns the old "oa2_fake" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOa2Fake(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOa2Fake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOa2Fake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOa2Fake: %w", err)
	}
	return oldValue.Oa2Fake, nil
}

// ResetOa2Fake resets all changes to the "oa2_fake" field.
func (m *AccountMutation) ResetOa2Fake() {
	m.oa2_fake = nil
}

// SetOa2Client sets the "oa2_client" field.
func (m *AccountMutation) SetOa2Client(i int) {
	m.oa2_client = &i
	m.addoa2_client = nil
}

// Oa2Client returns the value of the "oa2_client" field in the mutation.
func (m *AccountMutation) Oa2Client() (r int, exists bool) {
	v := m.oa2_client
	if v == nil {
		return
	}
	return *v, true
}

// OldOa2Client returns the old "oa2_client" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOa2Client(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOa2Client is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOa2Client requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOa2Client: %w", err)
	}
	return oldValue.Oa2Client, nil
}

// AddOa2Client adds i to the "oa2_client" field.
func (m *AccountMutation) AddOa2Client(i int) {
	if m.addoa2_client != nil {
		*m.addoa2_client += i
	} else {
		m.addoa2_client = &i
	}
}

// AddedOa2Client returns the value that was added to the "oa2_client" field in this mutation.
func (m *AccountMutation) AddedOa2Client() (r int, exists bool) {
	v := m.addoa2_client
	if v == nil {
		return
	}
	return *v, true
}

// ResetOa2Client resets all changes to the "oa2_client" field.
func (m *AccountMutation) ResetOa2Client() {
	m.oa2_client = nil
	m.addoa2_client = nil
}

// SetCreator sets the "creator" field.
func (m *AccountMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AccountMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *AccountMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *AccountMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *AccountMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *AccountMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *AccountMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *AccountMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the "string_1" field.
func (m *AccountMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the value of the "string_1" field in the mutation.
func (m *AccountMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old "string_1" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 resets all changes to the "string_1" field.
func (m *AccountMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the "string_2" field.
func (m *AccountMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the value of the "string_2" field in the mutation.
func (m *AccountMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old "string_2" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 resets all changes to the "string_2" field.
func (m *AccountMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the "string_3" field.
func (m *AccountMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the value of the "string_3" field in the mutation.
func (m *AccountMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old "string_3" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 resets all changes to the "string_3" field.
func (m *AccountMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the "number_1" field.
func (m *AccountMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the value of the "number_1" field in the mutation.
func (m *AccountMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old "number_1" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to the "number_1" field.
func (m *AccountMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the "number_1" field in this mutation.
func (m *AccountMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 resets all changes to the "number_1" field.
func (m *AccountMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the "number_2" field.
func (m *AccountMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the value of the "number_2" field in the mutation.
func (m *AccountMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old "number_2" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to the "number_2" field.
func (m *AccountMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the "number_2" field in this mutation.
func (m *AccountMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 resets all changes to the "number_2" field.
func (m *AccountMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the "number_3" field.
func (m *AccountMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the value of the "number_3" field in the mutation.
func (m *AccountMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old "number_3" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to the "number_3" field.
func (m *AccountMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the "number_3" field in this mutation.
func (m *AccountMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 resets all changes to the "number_3" field.
func (m *AccountMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.pid != nil {
		fields = append(fields, account.FieldPid)
	}
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.account_typ != nil {
		fields = append(fields, account.FieldAccountTyp)
	}
	if m.account_kid != nil {
		fields = append(fields, account.FieldAccountKid)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.password_salt != nil {
		fields = append(fields, account.FieldPasswordSalt)
	}
	if m.password_type != nil {
		fields = append(fields, account.FieldPasswordType)
	}
	if m.verify_secret != nil {
		fields = append(fields, account.FieldVerifySecret)
	}
	if m.verify_type != nil {
		fields = append(fields, account.FieldVerifyType)
	}
	if m.user_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.role_id != nil {
		fields = append(fields, account.FieldRoleID)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.oa2_token != nil {
		fields = append(fields, account.FieldOa2Token)
	}
	if m.oa2_expired != nil {
		fields = append(fields, account.FieldOa2Expired)
	}
	if m.oa2_fake != nil {
		fields = append(fields, account.FieldOa2Fake)
	}
	if m.oa2_client != nil {
		fields = append(fields, account.FieldOa2Client)
	}
	if m.creator != nil {
		fields = append(fields, account.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, account.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, account.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, account.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, account.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, account.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, account.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, account.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldPid:
		return m.Pid()
	case account.FieldAccount:
		return m.Account()
	case account.FieldAccountTyp:
		return m.AccountTyp()
	case account.FieldAccountKid:
		return m.AccountKid()
	case account.FieldPassword:
		return m.Password()
	case account.FieldPasswordSalt:
		return m.PasswordSalt()
	case account.FieldPasswordType:
		return m.PasswordType()
	case account.FieldVerifySecret:
		return m.VerifySecret()
	case account.FieldVerifyType:
		return m.VerifyType()
	case account.FieldUserID:
		return m.UserID()
	case account.FieldRoleID:
		return m.RoleID()
	case account.FieldStatus:
		return m.Status()
	case account.FieldDescription:
		return m.Description()
	case account.FieldOa2Token:
		return m.Oa2Token()
	case account.FieldOa2Expired:
		return m.Oa2Expired()
	case account.FieldOa2Fake:
		return m.Oa2Fake()
	case account.FieldOa2Client:
		return m.Oa2Client()
	case account.FieldCreator:
		return m.Creator()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldVersion:
		return m.Version()
	case account.FieldString1:
		return m.String1()
	case account.FieldString2:
		return m.String2()
	case account.FieldString3:
		return m.String3()
	case account.FieldNumber1:
		return m.Number1()
	case account.FieldNumber2:
		return m.Number2()
	case account.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldPid:
		return m.OldPid(ctx)
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldAccountTyp:
		return m.OldAccountTyp(ctx)
	case account.FieldAccountKid:
		return m.OldAccountKid(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldPasswordSalt:
		return m.OldPasswordSalt(ctx)
	case account.FieldPasswordType:
		return m.OldPasswordType(ctx)
	case account.FieldVerifySecret:
		return m.OldVerifySecret(ctx)
	case account.FieldVerifyType:
		return m.OldVerifyType(ctx)
	case account.FieldUserID:
		return m.OldUserID(ctx)
	case account.FieldRoleID:
		return m.OldRoleID(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldOa2Token:
		return m.OldOa2Token(ctx)
	case account.FieldOa2Expired:
		return m.OldOa2Expired(ctx)
	case account.FieldOa2Fake:
		return m.OldOa2Fake(ctx)
	case account.FieldOa2Client:
		return m.OldOa2Client(ctx)
	case account.FieldCreator:
		return m.OldCreator(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldVersion:
		return m.OldVersion(ctx)
	case account.FieldString1:
		return m.OldString1(ctx)
	case account.FieldString2:
		return m.OldString2(ctx)
	case account.FieldString3:
		return m.OldString3(ctx)
	case account.FieldNumber1:
		return m.OldNumber1(ctx)
	case account.FieldNumber2:
		return m.OldNumber2(ctx)
	case account.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldPid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldAccountTyp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountTyp(v)
		return nil
	case account.FieldAccountKid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountKid(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldPasswordSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordSalt(v)
		return nil
	case account.FieldPasswordType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordType(v)
		return nil
	case account.FieldVerifySecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifySecret(v)
		return nil
	case account.FieldVerifyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyType(v)
		return nil
	case account.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case account.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldOa2Token:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOa2Token(v)
		return nil
	case account.FieldOa2Expired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOa2Expired(v)
		return nil
	case account.FieldOa2Fake:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOa2Fake(v)
		return nil
	case account.FieldOa2Client:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOa2Client(v)
		return nil
	case account.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case account.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case account.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case account.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case account.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case account.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case account.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.addrole_id != nil {
		fields = append(fields, account.FieldRoleID)
	}
	if m.addstatus != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.addoa2_client != nil {
		fields = append(fields, account.FieldOa2Client)
	}
	if m.addversion != nil {
		fields = append(fields, account.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, account.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, account.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, account.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.AddedUserID()
	case account.FieldRoleID:
		return m.AddedRoleID()
	case account.FieldStatus:
		return m.AddedStatus()
	case account.FieldOa2Client:
		return m.AddedOa2Client()
	case account.FieldVersion:
		return m.AddedVersion()
	case account.FieldNumber1:
		return m.AddedNumber1()
	case account.FieldNumber2:
		return m.AddedNumber2()
	case account.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case account.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case account.FieldOa2Client:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOa2Client(v)
		return nil
	case account.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case account.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case account.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case account.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldPid:
		m.ResetPid()
		return nil
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldAccountTyp:
		m.ResetAccountTyp()
		return nil
	case account.FieldAccountKid:
		m.ResetAccountKid()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldPasswordSalt:
		m.ResetPasswordSalt()
		return nil
	case account.FieldPasswordType:
		m.ResetPasswordType()
		return nil
	case account.FieldVerifySecret:
		m.ResetVerifySecret()
		return nil
	case account.FieldVerifyType:
		m.ResetVerifyType()
		return nil
	case account.FieldUserID:
		m.ResetUserID()
		return nil
	case account.FieldRoleID:
		m.ResetRoleID()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldOa2Token:
		m.ResetOa2Token()
		return nil
	case account.FieldOa2Expired:
		m.ResetOa2Expired()
		return nil
	case account.FieldOa2Fake:
		m.ResetOa2Fake()
		return nil
	case account.FieldOa2Client:
		m.ResetOa2Client()
		return nil
	case account.FieldCreator:
		m.ResetCreator()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldVersion:
		m.ResetVersion()
		return nil
	case account.FieldString1:
		m.ResetString1()
		return nil
	case account.FieldString2:
		m.ResetString2()
		return nil
	case account.FieldString3:
		m.ResetString3()
		return nil
	case account.FieldNumber1:
		m.ResetNumber1()
		return nil
	case account.FieldNumber2:
		m.ResetNumber2()
		return nil
	case account.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}
