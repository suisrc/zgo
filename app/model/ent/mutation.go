// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/suisrc/zgo/app/model/ent/account"
	"github.com/suisrc/zgo/app/model/ent/menu"
	"github.com/suisrc/zgo/app/model/ent/menuaction"
	"github.com/suisrc/zgo/app/model/ent/menurole"
	"github.com/suisrc/zgo/app/model/ent/oauth2account"
	"github.com/suisrc/zgo/app/model/ent/oauth2client"
	"github.com/suisrc/zgo/app/model/ent/oauth2third"
	"github.com/suisrc/zgo/app/model/ent/oauth2token"
	"github.com/suisrc/zgo/app/model/ent/resource"
	"github.com/suisrc/zgo/app/model/ent/resourcerole"
	"github.com/suisrc/zgo/app/model/ent/resourceuser"
	"github.com/suisrc/zgo/app/model/ent/role"
	"github.com/suisrc/zgo/app/model/ent/rolerole"
	"github.com/suisrc/zgo/app/model/ent/tagcommon"
	"github.com/suisrc/zgo/app/model/ent/user"
	"github.com/suisrc/zgo/app/model/ent/userdetail"
	"github.com/suisrc/zgo/app/model/ent/usermessage"
	"github.com/suisrc/zgo/app/model/ent/userrole"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount       = "Account"
	TypeMenu          = "Menu"
	TypeMenuAction    = "MenuAction"
	TypeMenuRole      = "MenuRole"
	TypeOauth2Account = "Oauth2Account"
	TypeOauth2Client  = "Oauth2Client"
	TypeOauth2Third   = "Oauth2Third"
	TypeOauth2Token   = "Oauth2Token"
	TypeResource      = "Resource"
	TypeResourceRole  = "ResourceRole"
	TypeResourceUser  = "ResourceUser"
	TypeRole          = "Role"
	TypeRoleRole      = "RoleRole"
	TypeTagCommon     = "TagCommon"
	TypeUser          = "User"
	TypeUserDetail    = "UserDetail"
	TypeUserMessage   = "UserMessage"
	TypeUserRole      = "UserRole"
)

// AccountMutation represents an operation that mutate the Accounts
// nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	account       *string
	account_type  *string
	platform      *string
	verify_type   *string
	password      *string
	password_salt *string
	password_type *string
	user_id       *int
	adduser_id    *int
	role_id       *int
	addrole_id    *int
	status        *int
	addstatus     *int
	desc          *string
	oauth2_id     *int
	addoauth2_id  *int
	oauth2_token  *string
	oauth2_time   *time.Time
	token_fake    *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	string_1      *string
	string_2      *string
	string_3      *string
	number_1      *int
	addnumber_1   *int
	number_2      *int
	addnumber_2   *int
	number_3      *int
	addnumber_3   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Account, error)
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows to manage the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for $n.Name.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the id field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAccount sets the account field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the account value in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old account value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount reset all changes of the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
}

// SetAccountType sets the account_type field.
func (m *AccountMutation) SetAccountType(s string) {
	m.account_type = &s
}

// AccountType returns the account_type value in the mutation.
func (m *AccountMutation) AccountType() (r string, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old account_type value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldAccountType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType reset all changes of the "account_type" field.
func (m *AccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetPlatform sets the platform field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the platform value in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old platform value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatform is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform reset all changes of the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetVerifyType sets the verify_type field.
func (m *AccountMutation) SetVerifyType(s string) {
	m.verify_type = &s
}

// VerifyType returns the verify_type value in the mutation.
func (m *AccountMutation) VerifyType() (r string, exists bool) {
	v := m.verify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyType returns the old verify_type value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldVerifyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVerifyType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVerifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyType: %w", err)
	}
	return oldValue.VerifyType, nil
}

// ResetVerifyType reset all changes of the "verify_type" field.
func (m *AccountMutation) ResetVerifyType() {
	m.verify_type = nil
}

// SetPassword sets the password field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordSalt sets the password_salt field.
func (m *AccountMutation) SetPasswordSalt(s string) {
	m.password_salt = &s
}

// PasswordSalt returns the password_salt value in the mutation.
func (m *AccountMutation) PasswordSalt() (r string, exists bool) {
	v := m.password_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordSalt returns the old password_salt value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldPasswordSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordSalt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordSalt: %w", err)
	}
	return oldValue.PasswordSalt, nil
}

// ResetPasswordSalt reset all changes of the "password_salt" field.
func (m *AccountMutation) ResetPasswordSalt() {
	m.password_salt = nil
}

// SetPasswordType sets the password_type field.
func (m *AccountMutation) SetPasswordType(s string) {
	m.password_type = &s
}

// PasswordType returns the password_type value in the mutation.
func (m *AccountMutation) PasswordType() (r string, exists bool) {
	v := m.password_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordType returns the old password_type value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldPasswordType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordType: %w", err)
	}
	return oldValue.PasswordType, nil
}

// ResetPasswordType reset all changes of the "password_type" field.
func (m *AccountMutation) ResetPasswordType() {
	m.password_type = nil
}

// SetUserID sets the user_id field.
func (m *AccountMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the user_id value in the mutation.
func (m *AccountMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to user_id.
func (m *AccountMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the user_id field in this mutation.
func (m *AccountMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID reset all changes of the "user_id" field.
func (m *AccountMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRoleID sets the role_id field.
func (m *AccountMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the role_id value in the mutation.
func (m *AccountMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old role_id value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to role_id.
func (m *AccountMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the role_id field in this mutation.
func (m *AccountMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID reset all changes of the "role_id" field.
func (m *AccountMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetStatus sets the status field.
func (m *AccountMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *AccountMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *AccountMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *AccountMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDesc sets the desc field.
func (m *AccountMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the desc value in the mutation.
func (m *AccountMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old desc value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc reset all changes of the "desc" field.
func (m *AccountMutation) ResetDesc() {
	m.desc = nil
}

// SetOauth2ID sets the oauth2_id field.
func (m *AccountMutation) SetOauth2ID(i int) {
	m.oauth2_id = &i
	m.addoauth2_id = nil
}

// Oauth2ID returns the oauth2_id value in the mutation.
func (m *AccountMutation) Oauth2ID() (r int, exists bool) {
	v := m.oauth2_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOauth2ID returns the old oauth2_id value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldOauth2ID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOauth2ID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOauth2ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauth2ID: %w", err)
	}
	return oldValue.Oauth2ID, nil
}

// AddOauth2ID adds i to oauth2_id.
func (m *AccountMutation) AddOauth2ID(i int) {
	if m.addoauth2_id != nil {
		*m.addoauth2_id += i
	} else {
		m.addoauth2_id = &i
	}
}

// AddedOauth2ID returns the value that was added to the oauth2_id field in this mutation.
func (m *AccountMutation) AddedOauth2ID() (r int, exists bool) {
	v := m.addoauth2_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOauth2ID reset all changes of the "oauth2_id" field.
func (m *AccountMutation) ResetOauth2ID() {
	m.oauth2_id = nil
	m.addoauth2_id = nil
}

// SetOauth2Token sets the oauth2_token field.
func (m *AccountMutation) SetOauth2Token(s string) {
	m.oauth2_token = &s
}

// Oauth2Token returns the oauth2_token value in the mutation.
func (m *AccountMutation) Oauth2Token() (r string, exists bool) {
	v := m.oauth2_token
	if v == nil {
		return
	}
	return *v, true
}

// OldOauth2Token returns the old oauth2_token value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldOauth2Token(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOauth2Token is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOauth2Token requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauth2Token: %w", err)
	}
	return oldValue.Oauth2Token, nil
}

// ResetOauth2Token reset all changes of the "oauth2_token" field.
func (m *AccountMutation) ResetOauth2Token() {
	m.oauth2_token = nil
}

// SetOauth2Time sets the oauth2_time field.
func (m *AccountMutation) SetOauth2Time(t time.Time) {
	m.oauth2_time = &t
}

// Oauth2Time returns the oauth2_time value in the mutation.
func (m *AccountMutation) Oauth2Time() (r time.Time, exists bool) {
	v := m.oauth2_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOauth2Time returns the old oauth2_time value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldOauth2Time(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOauth2Time is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOauth2Time requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauth2Time: %w", err)
	}
	return oldValue.Oauth2Time, nil
}

// ResetOauth2Time reset all changes of the "oauth2_time" field.
func (m *AccountMutation) ResetOauth2Time() {
	m.oauth2_time = nil
}

// SetTokenFake sets the token_fake field.
func (m *AccountMutation) SetTokenFake(s string) {
	m.token_fake = &s
}

// TokenFake returns the token_fake value in the mutation.
func (m *AccountMutation) TokenFake() (r string, exists bool) {
	v := m.token_fake
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenFake returns the old token_fake value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldTokenFake(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTokenFake is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTokenFake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenFake: %w", err)
	}
	return oldValue.TokenFake, nil
}

// ResetTokenFake reset all changes of the "token_fake" field.
func (m *AccountMutation) ResetTokenFake() {
	m.token_fake = nil
}

// SetCreator sets the creator field.
func (m *AccountMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *AccountMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *AccountMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *AccountMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *AccountMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *AccountMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *AccountMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *AccountMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the string_1 field.
func (m *AccountMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the string_1 value in the mutation.
func (m *AccountMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old string_1 value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 reset all changes of the "string_1" field.
func (m *AccountMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the string_2 field.
func (m *AccountMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the string_2 value in the mutation.
func (m *AccountMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old string_2 value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 reset all changes of the "string_2" field.
func (m *AccountMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the string_3 field.
func (m *AccountMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the string_3 value in the mutation.
func (m *AccountMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old string_3 value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 reset all changes of the "string_3" field.
func (m *AccountMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the number_1 field.
func (m *AccountMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the number_1 value in the mutation.
func (m *AccountMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old number_1 value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to number_1.
func (m *AccountMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the number_1 field in this mutation.
func (m *AccountMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 reset all changes of the "number_1" field.
func (m *AccountMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the number_2 field.
func (m *AccountMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the number_2 value in the mutation.
func (m *AccountMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old number_2 value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to number_2.
func (m *AccountMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the number_2 field in this mutation.
func (m *AccountMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 reset all changes of the "number_2" field.
func (m *AccountMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the number_3 field.
func (m *AccountMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the number_3 value in the mutation.
func (m *AccountMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old number_3 value of the Account.
// If the Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AccountMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to number_3.
func (m *AccountMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the number_3 field in this mutation.
func (m *AccountMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 reset all changes of the "number_3" field.
func (m *AccountMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.account_type != nil {
		fields = append(fields, account.FieldAccountType)
	}
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m.verify_type != nil {
		fields = append(fields, account.FieldVerifyType)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.password_salt != nil {
		fields = append(fields, account.FieldPasswordSalt)
	}
	if m.password_type != nil {
		fields = append(fields, account.FieldPasswordType)
	}
	if m.user_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.role_id != nil {
		fields = append(fields, account.FieldRoleID)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.desc != nil {
		fields = append(fields, account.FieldDesc)
	}
	if m.oauth2_id != nil {
		fields = append(fields, account.FieldOauth2ID)
	}
	if m.oauth2_token != nil {
		fields = append(fields, account.FieldOauth2Token)
	}
	if m.oauth2_time != nil {
		fields = append(fields, account.FieldOauth2Time)
	}
	if m.token_fake != nil {
		fields = append(fields, account.FieldTokenFake)
	}
	if m.creator != nil {
		fields = append(fields, account.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, account.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, account.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, account.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, account.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, account.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, account.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, account.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldAccount:
		return m.Account()
	case account.FieldAccountType:
		return m.AccountType()
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldVerifyType:
		return m.VerifyType()
	case account.FieldPassword:
		return m.Password()
	case account.FieldPasswordSalt:
		return m.PasswordSalt()
	case account.FieldPasswordType:
		return m.PasswordType()
	case account.FieldUserID:
		return m.UserID()
	case account.FieldRoleID:
		return m.RoleID()
	case account.FieldStatus:
		return m.Status()
	case account.FieldDesc:
		return m.Desc()
	case account.FieldOauth2ID:
		return m.Oauth2ID()
	case account.FieldOauth2Token:
		return m.Oauth2Token()
	case account.FieldOauth2Time:
		return m.Oauth2Time()
	case account.FieldTokenFake:
		return m.TokenFake()
	case account.FieldCreator:
		return m.Creator()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldVersion:
		return m.Version()
	case account.FieldString1:
		return m.String1()
	case account.FieldString2:
		return m.String2()
	case account.FieldString3:
		return m.String3()
	case account.FieldNumber1:
		return m.Number1()
	case account.FieldNumber2:
		return m.Number2()
	case account.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldAccountType:
		return m.OldAccountType(ctx)
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldVerifyType:
		return m.OldVerifyType(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldPasswordSalt:
		return m.OldPasswordSalt(ctx)
	case account.FieldPasswordType:
		return m.OldPasswordType(ctx)
	case account.FieldUserID:
		return m.OldUserID(ctx)
	case account.FieldRoleID:
		return m.OldRoleID(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldDesc:
		return m.OldDesc(ctx)
	case account.FieldOauth2ID:
		return m.OldOauth2ID(ctx)
	case account.FieldOauth2Token:
		return m.OldOauth2Token(ctx)
	case account.FieldOauth2Time:
		return m.OldOauth2Time(ctx)
	case account.FieldTokenFake:
		return m.OldTokenFake(ctx)
	case account.FieldCreator:
		return m.OldCreator(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldVersion:
		return m.OldVersion(ctx)
	case account.FieldString1:
		return m.OldString1(ctx)
	case account.FieldString2:
		return m.OldString2(ctx)
	case account.FieldString3:
		return m.OldString3(ctx)
	case account.FieldNumber1:
		return m.OldNumber1(ctx)
	case account.FieldNumber2:
		return m.OldNumber2(ctx)
	case account.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldAccountType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldVerifyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyType(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldPasswordSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordSalt(v)
		return nil
	case account.FieldPasswordType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordType(v)
		return nil
	case account.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case account.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case account.FieldOauth2ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauth2ID(v)
		return nil
	case account.FieldOauth2Token:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauth2Token(v)
		return nil
	case account.FieldOauth2Time:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauth2Time(v)
		return nil
	case account.FieldTokenFake:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenFake(v)
		return nil
	case account.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case account.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case account.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case account.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case account.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case account.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case account.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.addrole_id != nil {
		fields = append(fields, account.FieldRoleID)
	}
	if m.addstatus != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.addoauth2_id != nil {
		fields = append(fields, account.FieldOauth2ID)
	}
	if m.addversion != nil {
		fields = append(fields, account.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, account.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, account.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, account.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.AddedUserID()
	case account.FieldRoleID:
		return m.AddedRoleID()
	case account.FieldStatus:
		return m.AddedStatus()
	case account.FieldOauth2ID:
		return m.AddedOauth2ID()
	case account.FieldVersion:
		return m.AddedVersion()
	case account.FieldNumber1:
		return m.AddedNumber1()
	case account.FieldNumber2:
		return m.AddedNumber2()
	case account.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case account.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case account.FieldOauth2ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOauth2ID(v)
		return nil
	case account.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case account.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case account.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case account.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldAccountType:
		m.ResetAccountType()
		return nil
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldVerifyType:
		m.ResetVerifyType()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldPasswordSalt:
		m.ResetPasswordSalt()
		return nil
	case account.FieldPasswordType:
		m.ResetPasswordType()
		return nil
	case account.FieldUserID:
		m.ResetUserID()
		return nil
	case account.FieldRoleID:
		m.ResetRoleID()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldDesc:
		m.ResetDesc()
		return nil
	case account.FieldOauth2ID:
		m.ResetOauth2ID()
		return nil
	case account.FieldOauth2Token:
		m.ResetOauth2Token()
		return nil
	case account.FieldOauth2Time:
		m.ResetOauth2Time()
		return nil
	case account.FieldTokenFake:
		m.ResetTokenFake()
		return nil
	case account.FieldCreator:
		m.ResetCreator()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldVersion:
		m.ResetVersion()
		return nil
	case account.FieldString1:
		m.ResetString1()
		return nil
	case account.FieldString2:
		m.ResetString2()
		return nil
	case account.FieldString3:
		m.ResetString3()
		return nil
	case account.FieldNumber1:
		m.ResetNumber1()
		return nil
	case account.FieldNumber2:
		m.ResetNumber2()
		return nil
	case account.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// MenuMutation represents an operation that mutate the Menus
// nodes in the graph.
type MenuMutation struct {
	config
	op            Op
	typ           string
	id            *int
	parent_id     *string
	name          *string
	sequence      *int
	addsequence   *int
	icon          *string
	router        *string
	memo          *string
	status        *int
	addstatus     *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Menu, error)
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows to manage the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for $n.Name.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the id field of the mutation.
func withMenuID(id int) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetParentID sets the parent_id field.
func (m *MenuMutation) SetParentID(s string) {
	m.parent_id = &s
}

// ParentID returns the parent_id value in the mutation.
func (m *MenuMutation) ParentID() (r string, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old parent_id value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID reset all changes of the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent_id = nil
}

// SetName sets the name field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetSequence sets the sequence field.
func (m *MenuMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the sequence value in the mutation.
func (m *MenuMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old sequence value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequence is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to sequence.
func (m *MenuMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the sequence field in this mutation.
func (m *MenuMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence reset all changes of the "sequence" field.
func (m *MenuMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetIcon sets the icon field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the icon value in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old icon value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIcon is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon reset all changes of the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
}

// SetRouter sets the router field.
func (m *MenuMutation) SetRouter(s string) {
	m.router = &s
}

// Router returns the router value in the mutation.
func (m *MenuMutation) Router() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouter returns the old router value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRouter is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouter: %w", err)
	}
	return oldValue.Router, nil
}

// ResetRouter reset all changes of the "router" field.
func (m *MenuMutation) ResetRouter() {
	m.router = nil
}

// SetMemo sets the memo field.
func (m *MenuMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the memo value in the mutation.
func (m *MenuMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old memo value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldMemo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ResetMemo reset all changes of the "memo" field.
func (m *MenuMutation) ResetMemo() {
	m.memo = nil
}

// SetStatus sets the status field.
func (m *MenuMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *MenuMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *MenuMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *MenuMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreator sets the creator field.
func (m *MenuMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *MenuMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *MenuMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *MenuMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *MenuMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Menu.
// If the Menu object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *MenuMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *MenuMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *MenuMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.parent_id != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.sequence != nil {
		fields = append(fields, menu.FieldSequence)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.router != nil {
		fields = append(fields, menu.FieldRouter)
	}
	if m.memo != nil {
		fields = append(fields, menu.FieldMemo)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.creator != nil {
		fields = append(fields, menu.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, menu.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldName:
		return m.Name()
	case menu.FieldSequence:
		return m.Sequence()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldRouter:
		return m.Router()
	case menu.FieldMemo:
		return m.Memo()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldCreator:
		return m.Creator()
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldSequence:
		return m.OldSequence(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldRouter:
		return m.OldRouter(ctx)
	case menu.FieldMemo:
		return m.OldMemo(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldCreator:
		return m.OldCreator(ctx)
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouter(v)
		return nil
	case menu.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, menu.FieldSequence)
	}
	if m.addstatus != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.addversion != nil {
		fields = append(fields, menu.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldSequence:
		return m.AddedSequence()
	case menu.FieldStatus:
		return m.AddedStatus()
	case menu.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case menu.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MenuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldSequence:
		m.ResetSequence()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldRouter:
		m.ResetRouter()
		return nil
	case menu.FieldMemo:
		m.ResetMemo()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldCreator:
		m.ResetCreator()
		return nil
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuActionMutation represents an operation that mutate the MenuActions
// nodes in the graph.
type MenuActionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	menu_id       *int
	addmenu_id    *int
	role_id       *int
	addrole_id    *int
	code          *string
	name          *string
	disable       *int
	adddisable    *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MenuAction, error)
}

var _ ent.Mutation = (*MenuActionMutation)(nil)

// menuactionOption allows to manage the mutation configuration using functional options.
type menuactionOption func(*MenuActionMutation)

// newMenuActionMutation creates new mutation for $n.Name.
func newMenuActionMutation(c config, op Op, opts ...menuactionOption) *MenuActionMutation {
	m := &MenuActionMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuActionID sets the id field of the mutation.
func withMenuActionID(id int) menuactionOption {
	return func(m *MenuActionMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuAction
		)
		m.oldValue = func(ctx context.Context) (*MenuAction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuAction sets the old MenuAction of the mutation.
func withMenuAction(node *MenuAction) menuactionOption {
	return func(m *MenuActionMutation) {
		m.oldValue = func(context.Context) (*MenuAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MenuActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMenuID sets the menu_id field.
func (m *MenuActionMutation) SetMenuID(i int) {
	m.menu_id = &i
	m.addmenu_id = nil
}

// MenuID returns the menu_id value in the mutation.
func (m *MenuActionMutation) MenuID() (r int, exists bool) {
	v := m.menu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old menu_id value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldMenuID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMenuID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// AddMenuID adds i to menu_id.
func (m *MenuActionMutation) AddMenuID(i int) {
	if m.addmenu_id != nil {
		*m.addmenu_id += i
	} else {
		m.addmenu_id = &i
	}
}

// AddedMenuID returns the value that was added to the menu_id field in this mutation.
func (m *MenuActionMutation) AddedMenuID() (r int, exists bool) {
	v := m.addmenu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuID reset all changes of the "menu_id" field.
func (m *MenuActionMutation) ResetMenuID() {
	m.menu_id = nil
	m.addmenu_id = nil
}

// SetRoleID sets the role_id field.
func (m *MenuActionMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the role_id value in the mutation.
func (m *MenuActionMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old role_id value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to role_id.
func (m *MenuActionMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the role_id field in this mutation.
func (m *MenuActionMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID reset all changes of the "role_id" field.
func (m *MenuActionMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetCode sets the code field.
func (m *MenuActionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *MenuActionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *MenuActionMutation) ResetCode() {
	m.code = nil
}

// SetName sets the name field.
func (m *MenuActionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MenuActionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MenuActionMutation) ResetName() {
	m.name = nil
}

// SetDisable sets the disable field.
func (m *MenuActionMutation) SetDisable(i int) {
	m.disable = &i
	m.adddisable = nil
}

// Disable returns the disable value in the mutation.
func (m *MenuActionMutation) Disable() (r int, exists bool) {
	v := m.disable
	if v == nil {
		return
	}
	return *v, true
}

// OldDisable returns the old disable value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldDisable(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisable is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisable: %w", err)
	}
	return oldValue.Disable, nil
}

// AddDisable adds i to disable.
func (m *MenuActionMutation) AddDisable(i int) {
	if m.adddisable != nil {
		*m.adddisable += i
	} else {
		m.adddisable = &i
	}
}

// AddedDisable returns the value that was added to the disable field in this mutation.
func (m *MenuActionMutation) AddedDisable() (r int, exists bool) {
	v := m.adddisable
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisable reset all changes of the "disable" field.
func (m *MenuActionMutation) ResetDisable() {
	m.disable = nil
	m.adddisable = nil
}

// SetCreator sets the creator field.
func (m *MenuActionMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *MenuActionMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *MenuActionMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *MenuActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MenuActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MenuActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MenuActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MenuActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MenuActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *MenuActionMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *MenuActionMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the MenuAction.
// If the MenuAction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuActionMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *MenuActionMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *MenuActionMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *MenuActionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *MenuActionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MenuAction).
func (m *MenuActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MenuActionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.menu_id != nil {
		fields = append(fields, menuaction.FieldMenuID)
	}
	if m.role_id != nil {
		fields = append(fields, menuaction.FieldRoleID)
	}
	if m.code != nil {
		fields = append(fields, menuaction.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, menuaction.FieldName)
	}
	if m.disable != nil {
		fields = append(fields, menuaction.FieldDisable)
	}
	if m.creator != nil {
		fields = append(fields, menuaction.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, menuaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuaction.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, menuaction.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MenuActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuaction.FieldMenuID:
		return m.MenuID()
	case menuaction.FieldRoleID:
		return m.RoleID()
	case menuaction.FieldCode:
		return m.Code()
	case menuaction.FieldName:
		return m.Name()
	case menuaction.FieldDisable:
		return m.Disable()
	case menuaction.FieldCreator:
		return m.Creator()
	case menuaction.FieldCreatedAt:
		return m.CreatedAt()
	case menuaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuaction.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MenuActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuaction.FieldMenuID:
		return m.OldMenuID(ctx)
	case menuaction.FieldRoleID:
		return m.OldRoleID(ctx)
	case menuaction.FieldCode:
		return m.OldCode(ctx)
	case menuaction.FieldName:
		return m.OldName(ctx)
	case menuaction.FieldDisable:
		return m.OldDisable(ctx)
	case menuaction.FieldCreator:
		return m.OldCreator(ctx)
	case menuaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuaction.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown MenuAction field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuaction.FieldMenuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	case menuaction.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case menuaction.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case menuaction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menuaction.FieldDisable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisable(v)
		return nil
	case menuaction.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case menuaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuaction.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MenuAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MenuActionMutation) AddedFields() []string {
	var fields []string
	if m.addmenu_id != nil {
		fields = append(fields, menuaction.FieldMenuID)
	}
	if m.addrole_id != nil {
		fields = append(fields, menuaction.FieldRoleID)
	}
	if m.adddisable != nil {
		fields = append(fields, menuaction.FieldDisable)
	}
	if m.addversion != nil {
		fields = append(fields, menuaction.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MenuActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuaction.FieldMenuID:
		return m.AddedMenuID()
	case menuaction.FieldRoleID:
		return m.AddedRoleID()
	case menuaction.FieldDisable:
		return m.AddedDisable()
	case menuaction.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuaction.FieldMenuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuID(v)
		return nil
	case menuaction.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case menuaction.FieldDisable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisable(v)
		return nil
	case menuaction.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MenuAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MenuActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MenuActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MenuAction nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MenuActionMutation) ResetField(name string) error {
	switch name {
	case menuaction.FieldMenuID:
		m.ResetMenuID()
		return nil
	case menuaction.FieldRoleID:
		m.ResetRoleID()
		return nil
	case menuaction.FieldCode:
		m.ResetCode()
		return nil
	case menuaction.FieldName:
		m.ResetName()
		return nil
	case menuaction.FieldDisable:
		m.ResetDisable()
		return nil
	case menuaction.FieldCreator:
		m.ResetCreator()
		return nil
	case menuaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuaction.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown MenuAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MenuActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MenuActionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MenuActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MenuActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MenuActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MenuActionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MenuActionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MenuAction unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MenuActionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MenuAction edge %s", name)
}

// MenuRoleMutation represents an operation that mutate the MenuRoles
// nodes in the graph.
type MenuRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role_id       *int
	addrole_id    *int
	user_id       *int
	adduser_id    *int
	menu_id       *int
	addmenu_id    *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MenuRole, error)
}

var _ ent.Mutation = (*MenuRoleMutation)(nil)

// menuroleOption allows to manage the mutation configuration using functional options.
type menuroleOption func(*MenuRoleMutation)

// newMenuRoleMutation creates new mutation for $n.Name.
func newMenuRoleMutation(c config, op Op, opts ...menuroleOption) *MenuRoleMutation {
	m := &MenuRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuRoleID sets the id field of the mutation.
func withMenuRoleID(id int) menuroleOption {
	return func(m *MenuRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuRole
		)
		m.oldValue = func(ctx context.Context) (*MenuRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuRole sets the old MenuRole of the mutation.
func withMenuRole(node *MenuRole) menuroleOption {
	return func(m *MenuRoleMutation) {
		m.oldValue = func(context.Context) (*MenuRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MenuRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoleID sets the role_id field.
func (m *MenuRoleMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the role_id value in the mutation.
func (m *MenuRoleMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old role_id value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to role_id.
func (m *MenuRoleMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the role_id field in this mutation.
func (m *MenuRoleMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID reset all changes of the "role_id" field.
func (m *MenuRoleMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetUserID sets the user_id field.
func (m *MenuRoleMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the user_id value in the mutation.
func (m *MenuRoleMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to user_id.
func (m *MenuRoleMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the user_id field in this mutation.
func (m *MenuRoleMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID reset all changes of the "user_id" field.
func (m *MenuRoleMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetMenuID sets the menu_id field.
func (m *MenuRoleMutation) SetMenuID(i int) {
	m.menu_id = &i
	m.addmenu_id = nil
}

// MenuID returns the menu_id value in the mutation.
func (m *MenuRoleMutation) MenuID() (r int, exists bool) {
	v := m.menu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old menu_id value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldMenuID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMenuID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// AddMenuID adds i to menu_id.
func (m *MenuRoleMutation) AddMenuID(i int) {
	if m.addmenu_id != nil {
		*m.addmenu_id += i
	} else {
		m.addmenu_id = &i
	}
}

// AddedMenuID returns the value that was added to the menu_id field in this mutation.
func (m *MenuRoleMutation) AddedMenuID() (r int, exists bool) {
	v := m.addmenu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuID reset all changes of the "menu_id" field.
func (m *MenuRoleMutation) ResetMenuID() {
	m.menu_id = nil
	m.addmenu_id = nil
}

// SetCreator sets the creator field.
func (m *MenuRoleMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *MenuRoleMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *MenuRoleMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *MenuRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MenuRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MenuRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MenuRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MenuRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MenuRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *MenuRoleMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *MenuRoleMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the MenuRole.
// If the MenuRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MenuRoleMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *MenuRoleMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *MenuRoleMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *MenuRoleMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *MenuRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MenuRole).
func (m *MenuRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MenuRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.role_id != nil {
		fields = append(fields, menurole.FieldRoleID)
	}
	if m.user_id != nil {
		fields = append(fields, menurole.FieldUserID)
	}
	if m.menu_id != nil {
		fields = append(fields, menurole.FieldMenuID)
	}
	if m.creator != nil {
		fields = append(fields, menurole.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, menurole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menurole.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, menurole.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MenuRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menurole.FieldRoleID:
		return m.RoleID()
	case menurole.FieldUserID:
		return m.UserID()
	case menurole.FieldMenuID:
		return m.MenuID()
	case menurole.FieldCreator:
		return m.Creator()
	case menurole.FieldCreatedAt:
		return m.CreatedAt()
	case menurole.FieldUpdatedAt:
		return m.UpdatedAt()
	case menurole.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MenuRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menurole.FieldRoleID:
		return m.OldRoleID(ctx)
	case menurole.FieldUserID:
		return m.OldUserID(ctx)
	case menurole.FieldMenuID:
		return m.OldMenuID(ctx)
	case menurole.FieldCreator:
		return m.OldCreator(ctx)
	case menurole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menurole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menurole.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown MenuRole field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menurole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case menurole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case menurole.FieldMenuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	case menurole.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case menurole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menurole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menurole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MenuRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MenuRoleMutation) AddedFields() []string {
	var fields []string
	if m.addrole_id != nil {
		fields = append(fields, menurole.FieldRoleID)
	}
	if m.adduser_id != nil {
		fields = append(fields, menurole.FieldUserID)
	}
	if m.addmenu_id != nil {
		fields = append(fields, menurole.FieldMenuID)
	}
	if m.addversion != nil {
		fields = append(fields, menurole.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MenuRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menurole.FieldRoleID:
		return m.AddedRoleID()
	case menurole.FieldUserID:
		return m.AddedUserID()
	case menurole.FieldMenuID:
		return m.AddedMenuID()
	case menurole.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MenuRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menurole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case menurole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case menurole.FieldMenuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuID(v)
		return nil
	case menurole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MenuRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MenuRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MenuRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MenuRole nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MenuRoleMutation) ResetField(name string) error {
	switch name {
	case menurole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case menurole.FieldUserID:
		m.ResetUserID()
		return nil
	case menurole.FieldMenuID:
		m.ResetMenuID()
		return nil
	case menurole.FieldCreator:
		m.ResetCreator()
		return nil
	case menurole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menurole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menurole.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown MenuRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MenuRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MenuRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MenuRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MenuRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MenuRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MenuRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MenuRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MenuRole unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MenuRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MenuRole edge %s", name)
}

// Oauth2AccountMutation represents an operation that mutate the Oauth2Accounts
// nodes in the graph.
type Oauth2AccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	client_id     *int
	addclient_id  *int
	secret        *string
	expired       *time.Time
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	string_1      *string
	string_2      *string
	string_3      *string
	number_1      *int
	addnumber_1   *int
	number_2      *int
	addnumber_2   *int
	number_3      *int
	addnumber_3   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Oauth2Account, error)
}

var _ ent.Mutation = (*Oauth2AccountMutation)(nil)

// oauth2accountOption allows to manage the mutation configuration using functional options.
type oauth2accountOption func(*Oauth2AccountMutation)

// newOauth2AccountMutation creates new mutation for $n.Name.
func newOauth2AccountMutation(c config, op Op, opts ...oauth2accountOption) *Oauth2AccountMutation {
	m := &Oauth2AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2Account,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2AccountID sets the id field of the mutation.
func withOauth2AccountID(id int) oauth2accountOption {
	return func(m *Oauth2AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2Account
		)
		m.oldValue = func(ctx context.Context) (*Oauth2Account, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2Account sets the old Oauth2Account of the mutation.
func withOauth2Account(node *Oauth2Account) oauth2accountOption {
	return func(m *Oauth2AccountMutation) {
		m.oldValue = func(context.Context) (*Oauth2Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *Oauth2AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClientID sets the client_id field.
func (m *Oauth2AccountMutation) SetClientID(i int) {
	m.client_id = &i
	m.addclient_id = nil
}

// ClientID returns the client_id value in the mutation.
func (m *Oauth2AccountMutation) ClientID() (r int, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old client_id value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldClientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// AddClientID adds i to client_id.
func (m *Oauth2AccountMutation) AddClientID(i int) {
	if m.addclient_id != nil {
		*m.addclient_id += i
	} else {
		m.addclient_id = &i
	}
}

// AddedClientID returns the value that was added to the client_id field in this mutation.
func (m *Oauth2AccountMutation) AddedClientID() (r int, exists bool) {
	v := m.addclient_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientID reset all changes of the "client_id" field.
func (m *Oauth2AccountMutation) ResetClientID() {
	m.client_id = nil
	m.addclient_id = nil
}

// SetSecret sets the secret field.
func (m *Oauth2AccountMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the secret value in the mutation.
func (m *Oauth2AccountMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old secret value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret reset all changes of the "secret" field.
func (m *Oauth2AccountMutation) ResetSecret() {
	m.secret = nil
}

// SetExpired sets the expired field.
func (m *Oauth2AccountMutation) SetExpired(t time.Time) {
	m.expired = &t
}

// Expired returns the expired value in the mutation.
func (m *Oauth2AccountMutation) Expired() (r time.Time, exists bool) {
	v := m.expired
	if v == nil {
		return
	}
	return *v, true
}

// OldExpired returns the old expired value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpired is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpired: %w", err)
	}
	return oldValue.Expired, nil
}

// ResetExpired reset all changes of the "expired" field.
func (m *Oauth2AccountMutation) ResetExpired() {
	m.expired = nil
}

// SetCreator sets the creator field.
func (m *Oauth2AccountMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *Oauth2AccountMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *Oauth2AccountMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *Oauth2AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *Oauth2AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *Oauth2AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *Oauth2AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *Oauth2AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *Oauth2AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *Oauth2AccountMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *Oauth2AccountMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *Oauth2AccountMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *Oauth2AccountMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *Oauth2AccountMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the string_1 field.
func (m *Oauth2AccountMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the string_1 value in the mutation.
func (m *Oauth2AccountMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old string_1 value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 reset all changes of the "string_1" field.
func (m *Oauth2AccountMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the string_2 field.
func (m *Oauth2AccountMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the string_2 value in the mutation.
func (m *Oauth2AccountMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old string_2 value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 reset all changes of the "string_2" field.
func (m *Oauth2AccountMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the string_3 field.
func (m *Oauth2AccountMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the string_3 value in the mutation.
func (m *Oauth2AccountMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old string_3 value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 reset all changes of the "string_3" field.
func (m *Oauth2AccountMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the number_1 field.
func (m *Oauth2AccountMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the number_1 value in the mutation.
func (m *Oauth2AccountMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old number_1 value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to number_1.
func (m *Oauth2AccountMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the number_1 field in this mutation.
func (m *Oauth2AccountMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 reset all changes of the "number_1" field.
func (m *Oauth2AccountMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the number_2 field.
func (m *Oauth2AccountMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the number_2 value in the mutation.
func (m *Oauth2AccountMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old number_2 value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to number_2.
func (m *Oauth2AccountMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the number_2 field in this mutation.
func (m *Oauth2AccountMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 reset all changes of the "number_2" field.
func (m *Oauth2AccountMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the number_3 field.
func (m *Oauth2AccountMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the number_3 value in the mutation.
func (m *Oauth2AccountMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old number_3 value of the Oauth2Account.
// If the Oauth2Account object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2AccountMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to number_3.
func (m *Oauth2AccountMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the number_3 field in this mutation.
func (m *Oauth2AccountMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 reset all changes of the "number_3" field.
func (m *Oauth2AccountMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *Oauth2AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Oauth2Account).
func (m *Oauth2AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *Oauth2AccountMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.client_id != nil {
		fields = append(fields, oauth2account.FieldClientID)
	}
	if m.secret != nil {
		fields = append(fields, oauth2account.FieldSecret)
	}
	if m.expired != nil {
		fields = append(fields, oauth2account.FieldExpired)
	}
	if m.creator != nil {
		fields = append(fields, oauth2account.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, oauth2account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2account.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, oauth2account.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, oauth2account.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, oauth2account.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, oauth2account.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, oauth2account.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, oauth2account.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, oauth2account.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *Oauth2AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2account.FieldClientID:
		return m.ClientID()
	case oauth2account.FieldSecret:
		return m.Secret()
	case oauth2account.FieldExpired:
		return m.Expired()
	case oauth2account.FieldCreator:
		return m.Creator()
	case oauth2account.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2account.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2account.FieldVersion:
		return m.Version()
	case oauth2account.FieldString1:
		return m.String1()
	case oauth2account.FieldString2:
		return m.String2()
	case oauth2account.FieldString3:
		return m.String3()
	case oauth2account.FieldNumber1:
		return m.Number1()
	case oauth2account.FieldNumber2:
		return m.Number2()
	case oauth2account.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *Oauth2AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2account.FieldClientID:
		return m.OldClientID(ctx)
	case oauth2account.FieldSecret:
		return m.OldSecret(ctx)
	case oauth2account.FieldExpired:
		return m.OldExpired(ctx)
	case oauth2account.FieldCreator:
		return m.OldCreator(ctx)
	case oauth2account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2account.FieldVersion:
		return m.OldVersion(ctx)
	case oauth2account.FieldString1:
		return m.OldString1(ctx)
	case oauth2account.FieldString2:
		return m.OldString2(ctx)
	case oauth2account.FieldString3:
		return m.OldString3(ctx)
	case oauth2account.FieldNumber1:
		return m.OldNumber1(ctx)
	case oauth2account.FieldNumber2:
		return m.OldNumber2(ctx)
	case oauth2account.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2Account field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2account.FieldClientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauth2account.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case oauth2account.FieldExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpired(v)
		return nil
	case oauth2account.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case oauth2account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2account.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case oauth2account.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case oauth2account.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case oauth2account.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case oauth2account.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case oauth2account.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case oauth2account.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *Oauth2AccountMutation) AddedFields() []string {
	var fields []string
	if m.addclient_id != nil {
		fields = append(fields, oauth2account.FieldClientID)
	}
	if m.addversion != nil {
		fields = append(fields, oauth2account.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, oauth2account.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, oauth2account.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, oauth2account.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *Oauth2AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2account.FieldClientID:
		return m.AddedClientID()
	case oauth2account.FieldVersion:
		return m.AddedVersion()
	case oauth2account.FieldNumber1:
		return m.AddedNumber1()
	case oauth2account.FieldNumber2:
		return m.AddedNumber2()
	case oauth2account.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2account.FieldClientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientID(v)
		return nil
	case oauth2account.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case oauth2account.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case oauth2account.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case oauth2account.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *Oauth2AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *Oauth2AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2Account nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *Oauth2AccountMutation) ResetField(name string) error {
	switch name {
	case oauth2account.FieldClientID:
		m.ResetClientID()
		return nil
	case oauth2account.FieldSecret:
		m.ResetSecret()
		return nil
	case oauth2account.FieldExpired:
		m.ResetExpired()
		return nil
	case oauth2account.FieldCreator:
		m.ResetCreator()
		return nil
	case oauth2account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2account.FieldVersion:
		m.ResetVersion()
		return nil
	case oauth2account.FieldString1:
		m.ResetString1()
		return nil
	case oauth2account.FieldString2:
		m.ResetString2()
		return nil
	case oauth2account.FieldString3:
		m.ResetString3()
		return nil
	case oauth2account.FieldNumber1:
		m.ResetNumber1()
		return nil
	case oauth2account.FieldNumber2:
		m.ResetNumber2()
		return nil
	case oauth2account.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown Oauth2Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *Oauth2AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *Oauth2AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *Oauth2AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *Oauth2AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *Oauth2AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *Oauth2AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *Oauth2AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Account unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *Oauth2AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Account edge %s", name)
}

// Oauth2ClientMutation represents an operation that mutate the Oauth2Clients
// nodes in the graph.
type Oauth2ClientMutation struct {
	config
	op              Op
	typ             string
	id              *int
	client_key      *string
	audience        *string
	issuer          *string
	expired         *int
	addexpired      *int
	token_type      *int
	addtoken_type   *int
	s_method        *string
	s_secret        *string
	token_getter    *string
	signin_url      *string
	signin_force    *int
	addsignin_force *int
	creator         *string
	created_at      *time.Time
	updated_at      *time.Time
	version         *int
	addversion      *int
	string_1        *string
	string_2        *string
	string_3        *string
	number_1        *int
	addnumber_1     *int
	number_2        *int
	addnumber_2     *int
	number_3        *int
	addnumber_3     *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Oauth2Client, error)
}

var _ ent.Mutation = (*Oauth2ClientMutation)(nil)

// oauth2clientOption allows to manage the mutation configuration using functional options.
type oauth2clientOption func(*Oauth2ClientMutation)

// newOauth2ClientMutation creates new mutation for $n.Name.
func newOauth2ClientMutation(c config, op Op, opts ...oauth2clientOption) *Oauth2ClientMutation {
	m := &Oauth2ClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2Client,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2ClientID sets the id field of the mutation.
func withOauth2ClientID(id int) oauth2clientOption {
	return func(m *Oauth2ClientMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2Client
		)
		m.oldValue = func(ctx context.Context) (*Oauth2Client, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2Client.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2Client sets the old Oauth2Client of the mutation.
func withOauth2Client(node *Oauth2Client) oauth2clientOption {
	return func(m *Oauth2ClientMutation) {
		m.oldValue = func(context.Context) (*Oauth2Client, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2ClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2ClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *Oauth2ClientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClientKey sets the client_key field.
func (m *Oauth2ClientMutation) SetClientKey(s string) {
	m.client_key = &s
}

// ClientKey returns the client_key value in the mutation.
func (m *Oauth2ClientMutation) ClientKey() (r string, exists bool) {
	v := m.client_key
	if v == nil {
		return
	}
	return *v, true
}

// OldClientKey returns the old client_key value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldClientKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientKey: %w", err)
	}
	return oldValue.ClientKey, nil
}

// ResetClientKey reset all changes of the "client_key" field.
func (m *Oauth2ClientMutation) ResetClientKey() {
	m.client_key = nil
}

// SetAudience sets the audience field.
func (m *Oauth2ClientMutation) SetAudience(s string) {
	m.audience = &s
}

// Audience returns the audience value in the mutation.
func (m *Oauth2ClientMutation) Audience() (r string, exists bool) {
	v := m.audience
	if v == nil {
		return
	}
	return *v, true
}

// OldAudience returns the old audience value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldAudience(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAudience is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudience: %w", err)
	}
	return oldValue.Audience, nil
}

// ResetAudience reset all changes of the "audience" field.
func (m *Oauth2ClientMutation) ResetAudience() {
	m.audience = nil
}

// SetIssuer sets the issuer field.
func (m *Oauth2ClientMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the issuer value in the mutation.
func (m *Oauth2ClientMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old issuer value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIssuer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer reset all changes of the "issuer" field.
func (m *Oauth2ClientMutation) ResetIssuer() {
	m.issuer = nil
}

// SetExpired sets the expired field.
func (m *Oauth2ClientMutation) SetExpired(i int) {
	m.expired = &i
	m.addexpired = nil
}

// Expired returns the expired value in the mutation.
func (m *Oauth2ClientMutation) Expired() (r int, exists bool) {
	v := m.expired
	if v == nil {
		return
	}
	return *v, true
}

// OldExpired returns the old expired value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldExpired(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpired is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpired: %w", err)
	}
	return oldValue.Expired, nil
}

// AddExpired adds i to expired.
func (m *Oauth2ClientMutation) AddExpired(i int) {
	if m.addexpired != nil {
		*m.addexpired += i
	} else {
		m.addexpired = &i
	}
}

// AddedExpired returns the value that was added to the expired field in this mutation.
func (m *Oauth2ClientMutation) AddedExpired() (r int, exists bool) {
	v := m.addexpired
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpired reset all changes of the "expired" field.
func (m *Oauth2ClientMutation) ResetExpired() {
	m.expired = nil
	m.addexpired = nil
}

// SetTokenType sets the token_type field.
func (m *Oauth2ClientMutation) SetTokenType(i int) {
	m.token_type = &i
	m.addtoken_type = nil
}

// TokenType returns the token_type value in the mutation.
func (m *Oauth2ClientMutation) TokenType() (r int, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old token_type value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldTokenType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTokenType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// AddTokenType adds i to token_type.
func (m *Oauth2ClientMutation) AddTokenType(i int) {
	if m.addtoken_type != nil {
		*m.addtoken_type += i
	} else {
		m.addtoken_type = &i
	}
}

// AddedTokenType returns the value that was added to the token_type field in this mutation.
func (m *Oauth2ClientMutation) AddedTokenType() (r int, exists bool) {
	v := m.addtoken_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenType reset all changes of the "token_type" field.
func (m *Oauth2ClientMutation) ResetTokenType() {
	m.token_type = nil
	m.addtoken_type = nil
}

// SetSMethod sets the s_method field.
func (m *Oauth2ClientMutation) SetSMethod(s string) {
	m.s_method = &s
}

// SMethod returns the s_method value in the mutation.
func (m *Oauth2ClientMutation) SMethod() (r string, exists bool) {
	v := m.s_method
	if v == nil {
		return
	}
	return *v, true
}

// OldSMethod returns the old s_method value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldSMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMethod: %w", err)
	}
	return oldValue.SMethod, nil
}

// ResetSMethod reset all changes of the "s_method" field.
func (m *Oauth2ClientMutation) ResetSMethod() {
	m.s_method = nil
}

// SetSSecret sets the s_secret field.
func (m *Oauth2ClientMutation) SetSSecret(s string) {
	m.s_secret = &s
}

// SSecret returns the s_secret value in the mutation.
func (m *Oauth2ClientMutation) SSecret() (r string, exists bool) {
	v := m.s_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSSecret returns the old s_secret value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldSSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSSecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSecret: %w", err)
	}
	return oldValue.SSecret, nil
}

// ResetSSecret reset all changes of the "s_secret" field.
func (m *Oauth2ClientMutation) ResetSSecret() {
	m.s_secret = nil
}

// SetTokenGetter sets the token_getter field.
func (m *Oauth2ClientMutation) SetTokenGetter(s string) {
	m.token_getter = &s
}

// TokenGetter returns the token_getter value in the mutation.
func (m *Oauth2ClientMutation) TokenGetter() (r string, exists bool) {
	v := m.token_getter
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenGetter returns the old token_getter value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldTokenGetter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTokenGetter is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTokenGetter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenGetter: %w", err)
	}
	return oldValue.TokenGetter, nil
}

// ResetTokenGetter reset all changes of the "token_getter" field.
func (m *Oauth2ClientMutation) ResetTokenGetter() {
	m.token_getter = nil
}

// SetSigninURL sets the signin_url field.
func (m *Oauth2ClientMutation) SetSigninURL(s string) {
	m.signin_url = &s
}

// SigninURL returns the signin_url value in the mutation.
func (m *Oauth2ClientMutation) SigninURL() (r string, exists bool) {
	v := m.signin_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninURL returns the old signin_url value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldSigninURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSigninURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSigninURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninURL: %w", err)
	}
	return oldValue.SigninURL, nil
}

// ResetSigninURL reset all changes of the "signin_url" field.
func (m *Oauth2ClientMutation) ResetSigninURL() {
	m.signin_url = nil
}

// SetSigninForce sets the signin_force field.
func (m *Oauth2ClientMutation) SetSigninForce(i int) {
	m.signin_force = &i
	m.addsignin_force = nil
}

// SigninForce returns the signin_force value in the mutation.
func (m *Oauth2ClientMutation) SigninForce() (r int, exists bool) {
	v := m.signin_force
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninForce returns the old signin_force value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldSigninForce(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSigninForce is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSigninForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninForce: %w", err)
	}
	return oldValue.SigninForce, nil
}

// AddSigninForce adds i to signin_force.
func (m *Oauth2ClientMutation) AddSigninForce(i int) {
	if m.addsignin_force != nil {
		*m.addsignin_force += i
	} else {
		m.addsignin_force = &i
	}
}

// AddedSigninForce returns the value that was added to the signin_force field in this mutation.
func (m *Oauth2ClientMutation) AddedSigninForce() (r int, exists bool) {
	v := m.addsignin_force
	if v == nil {
		return
	}
	return *v, true
}

// ResetSigninForce reset all changes of the "signin_force" field.
func (m *Oauth2ClientMutation) ResetSigninForce() {
	m.signin_force = nil
	m.addsignin_force = nil
}

// SetCreator sets the creator field.
func (m *Oauth2ClientMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *Oauth2ClientMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *Oauth2ClientMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *Oauth2ClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *Oauth2ClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *Oauth2ClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *Oauth2ClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *Oauth2ClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *Oauth2ClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *Oauth2ClientMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *Oauth2ClientMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *Oauth2ClientMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *Oauth2ClientMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *Oauth2ClientMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the string_1 field.
func (m *Oauth2ClientMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the string_1 value in the mutation.
func (m *Oauth2ClientMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old string_1 value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 reset all changes of the "string_1" field.
func (m *Oauth2ClientMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the string_2 field.
func (m *Oauth2ClientMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the string_2 value in the mutation.
func (m *Oauth2ClientMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old string_2 value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 reset all changes of the "string_2" field.
func (m *Oauth2ClientMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the string_3 field.
func (m *Oauth2ClientMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the string_3 value in the mutation.
func (m *Oauth2ClientMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old string_3 value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 reset all changes of the "string_3" field.
func (m *Oauth2ClientMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the number_1 field.
func (m *Oauth2ClientMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the number_1 value in the mutation.
func (m *Oauth2ClientMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old number_1 value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to number_1.
func (m *Oauth2ClientMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the number_1 field in this mutation.
func (m *Oauth2ClientMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 reset all changes of the "number_1" field.
func (m *Oauth2ClientMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the number_2 field.
func (m *Oauth2ClientMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the number_2 value in the mutation.
func (m *Oauth2ClientMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old number_2 value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to number_2.
func (m *Oauth2ClientMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the number_2 field in this mutation.
func (m *Oauth2ClientMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 reset all changes of the "number_2" field.
func (m *Oauth2ClientMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the number_3 field.
func (m *Oauth2ClientMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the number_3 value in the mutation.
func (m *Oauth2ClientMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old number_3 value of the Oauth2Client.
// If the Oauth2Client object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ClientMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to number_3.
func (m *Oauth2ClientMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the number_3 field in this mutation.
func (m *Oauth2ClientMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 reset all changes of the "number_3" field.
func (m *Oauth2ClientMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *Oauth2ClientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Oauth2Client).
func (m *Oauth2ClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *Oauth2ClientMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.client_key != nil {
		fields = append(fields, oauth2client.FieldClientKey)
	}
	if m.audience != nil {
		fields = append(fields, oauth2client.FieldAudience)
	}
	if m.issuer != nil {
		fields = append(fields, oauth2client.FieldIssuer)
	}
	if m.expired != nil {
		fields = append(fields, oauth2client.FieldExpired)
	}
	if m.token_type != nil {
		fields = append(fields, oauth2client.FieldTokenType)
	}
	if m.s_method != nil {
		fields = append(fields, oauth2client.FieldSMethod)
	}
	if m.s_secret != nil {
		fields = append(fields, oauth2client.FieldSSecret)
	}
	if m.token_getter != nil {
		fields = append(fields, oauth2client.FieldTokenGetter)
	}
	if m.signin_url != nil {
		fields = append(fields, oauth2client.FieldSigninURL)
	}
	if m.signin_force != nil {
		fields = append(fields, oauth2client.FieldSigninForce)
	}
	if m.creator != nil {
		fields = append(fields, oauth2client.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, oauth2client.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2client.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, oauth2client.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, oauth2client.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, oauth2client.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, oauth2client.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, oauth2client.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, oauth2client.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, oauth2client.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *Oauth2ClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2client.FieldClientKey:
		return m.ClientKey()
	case oauth2client.FieldAudience:
		return m.Audience()
	case oauth2client.FieldIssuer:
		return m.Issuer()
	case oauth2client.FieldExpired:
		return m.Expired()
	case oauth2client.FieldTokenType:
		return m.TokenType()
	case oauth2client.FieldSMethod:
		return m.SMethod()
	case oauth2client.FieldSSecret:
		return m.SSecret()
	case oauth2client.FieldTokenGetter:
		return m.TokenGetter()
	case oauth2client.FieldSigninURL:
		return m.SigninURL()
	case oauth2client.FieldSigninForce:
		return m.SigninForce()
	case oauth2client.FieldCreator:
		return m.Creator()
	case oauth2client.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2client.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2client.FieldVersion:
		return m.Version()
	case oauth2client.FieldString1:
		return m.String1()
	case oauth2client.FieldString2:
		return m.String2()
	case oauth2client.FieldString3:
		return m.String3()
	case oauth2client.FieldNumber1:
		return m.Number1()
	case oauth2client.FieldNumber2:
		return m.Number2()
	case oauth2client.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *Oauth2ClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2client.FieldClientKey:
		return m.OldClientKey(ctx)
	case oauth2client.FieldAudience:
		return m.OldAudience(ctx)
	case oauth2client.FieldIssuer:
		return m.OldIssuer(ctx)
	case oauth2client.FieldExpired:
		return m.OldExpired(ctx)
	case oauth2client.FieldTokenType:
		return m.OldTokenType(ctx)
	case oauth2client.FieldSMethod:
		return m.OldSMethod(ctx)
	case oauth2client.FieldSSecret:
		return m.OldSSecret(ctx)
	case oauth2client.FieldTokenGetter:
		return m.OldTokenGetter(ctx)
	case oauth2client.FieldSigninURL:
		return m.OldSigninURL(ctx)
	case oauth2client.FieldSigninForce:
		return m.OldSigninForce(ctx)
	case oauth2client.FieldCreator:
		return m.OldCreator(ctx)
	case oauth2client.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2client.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2client.FieldVersion:
		return m.OldVersion(ctx)
	case oauth2client.FieldString1:
		return m.OldString1(ctx)
	case oauth2client.FieldString2:
		return m.OldString2(ctx)
	case oauth2client.FieldString3:
		return m.OldString3(ctx)
	case oauth2client.FieldNumber1:
		return m.OldNumber1(ctx)
	case oauth2client.FieldNumber2:
		return m.OldNumber2(ctx)
	case oauth2client.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2Client field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2ClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2client.FieldClientKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientKey(v)
		return nil
	case oauth2client.FieldAudience:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudience(v)
		return nil
	case oauth2client.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case oauth2client.FieldExpired:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpired(v)
		return nil
	case oauth2client.FieldTokenType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case oauth2client.FieldSMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMethod(v)
		return nil
	case oauth2client.FieldSSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSecret(v)
		return nil
	case oauth2client.FieldTokenGetter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenGetter(v)
		return nil
	case oauth2client.FieldSigninURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninURL(v)
		return nil
	case oauth2client.FieldSigninForce:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninForce(v)
		return nil
	case oauth2client.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case oauth2client.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2client.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2client.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case oauth2client.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case oauth2client.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case oauth2client.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case oauth2client.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case oauth2client.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case oauth2client.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Client field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *Oauth2ClientMutation) AddedFields() []string {
	var fields []string
	if m.addexpired != nil {
		fields = append(fields, oauth2client.FieldExpired)
	}
	if m.addtoken_type != nil {
		fields = append(fields, oauth2client.FieldTokenType)
	}
	if m.addsignin_force != nil {
		fields = append(fields, oauth2client.FieldSigninForce)
	}
	if m.addversion != nil {
		fields = append(fields, oauth2client.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, oauth2client.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, oauth2client.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, oauth2client.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *Oauth2ClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2client.FieldExpired:
		return m.AddedExpired()
	case oauth2client.FieldTokenType:
		return m.AddedTokenType()
	case oauth2client.FieldSigninForce:
		return m.AddedSigninForce()
	case oauth2client.FieldVersion:
		return m.AddedVersion()
	case oauth2client.FieldNumber1:
		return m.AddedNumber1()
	case oauth2client.FieldNumber2:
		return m.AddedNumber2()
	case oauth2client.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2ClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2client.FieldExpired:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpired(v)
		return nil
	case oauth2client.FieldTokenType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenType(v)
		return nil
	case oauth2client.FieldSigninForce:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSigninForce(v)
		return nil
	case oauth2client.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case oauth2client.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case oauth2client.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case oauth2client.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Client numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *Oauth2ClientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *Oauth2ClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2ClientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2Client nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *Oauth2ClientMutation) ResetField(name string) error {
	switch name {
	case oauth2client.FieldClientKey:
		m.ResetClientKey()
		return nil
	case oauth2client.FieldAudience:
		m.ResetAudience()
		return nil
	case oauth2client.FieldIssuer:
		m.ResetIssuer()
		return nil
	case oauth2client.FieldExpired:
		m.ResetExpired()
		return nil
	case oauth2client.FieldTokenType:
		m.ResetTokenType()
		return nil
	case oauth2client.FieldSMethod:
		m.ResetSMethod()
		return nil
	case oauth2client.FieldSSecret:
		m.ResetSSecret()
		return nil
	case oauth2client.FieldTokenGetter:
		m.ResetTokenGetter()
		return nil
	case oauth2client.FieldSigninURL:
		m.ResetSigninURL()
		return nil
	case oauth2client.FieldSigninForce:
		m.ResetSigninForce()
		return nil
	case oauth2client.FieldCreator:
		m.ResetCreator()
		return nil
	case oauth2client.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2client.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2client.FieldVersion:
		m.ResetVersion()
		return nil
	case oauth2client.FieldString1:
		m.ResetString1()
		return nil
	case oauth2client.FieldString2:
		m.ResetString2()
		return nil
	case oauth2client.FieldString3:
		m.ResetString3()
		return nil
	case oauth2client.FieldNumber1:
		m.ResetNumber1()
		return nil
	case oauth2client.FieldNumber2:
		m.ResetNumber2()
		return nil
	case oauth2client.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown Oauth2Client field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *Oauth2ClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *Oauth2ClientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *Oauth2ClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *Oauth2ClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *Oauth2ClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *Oauth2ClientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *Oauth2ClientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Client unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *Oauth2ClientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Client edge %s", name)
}

// Oauth2ThirdMutation represents an operation that mutate the Oauth2Thirds
// nodes in the graph.
type Oauth2ThirdMutation struct {
	config
	op            Op
	typ           string
	id            *int
	platform      *string
	agent_id      *string
	suite_id      *string
	app_id        *string
	app_secret    *string
	authorize_url *string
	token_url     *string
	profile_url   *string
	domain_def    *string
	domain_check  *string
	js_secret     *string
	state_secret  *string
	callback      *int
	addcallback   *int
	cb_encrypt    *int
	addcb_encrypt *int
	cb_token      *string
	cb_encoding   *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	string_1      *string
	string_2      *string
	string_3      *string
	number_1      *int
	addnumber_1   *int
	number_2      *int
	addnumber_2   *int
	number_3      *int
	addnumber_3   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Oauth2Third, error)
}

var _ ent.Mutation = (*Oauth2ThirdMutation)(nil)

// oauth2thirdOption allows to manage the mutation configuration using functional options.
type oauth2thirdOption func(*Oauth2ThirdMutation)

// newOauth2ThirdMutation creates new mutation for $n.Name.
func newOauth2ThirdMutation(c config, op Op, opts ...oauth2thirdOption) *Oauth2ThirdMutation {
	m := &Oauth2ThirdMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2Third,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2ThirdID sets the id field of the mutation.
func withOauth2ThirdID(id int) oauth2thirdOption {
	return func(m *Oauth2ThirdMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2Third
		)
		m.oldValue = func(ctx context.Context) (*Oauth2Third, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2Third.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2Third sets the old Oauth2Third of the mutation.
func withOauth2Third(node *Oauth2Third) oauth2thirdOption {
	return func(m *Oauth2ThirdMutation) {
		m.oldValue = func(context.Context) (*Oauth2Third, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2ThirdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2ThirdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *Oauth2ThirdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPlatform sets the platform field.
func (m *Oauth2ThirdMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the platform value in the mutation.
func (m *Oauth2ThirdMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old platform value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatform is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform reset all changes of the "platform" field.
func (m *Oauth2ThirdMutation) ResetPlatform() {
	m.platform = nil
}

// SetAgentID sets the agent_id field.
func (m *Oauth2ThirdMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the agent_id value in the mutation.
func (m *Oauth2ThirdMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old agent_id value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID reset all changes of the "agent_id" field.
func (m *Oauth2ThirdMutation) ResetAgentID() {
	m.agent_id = nil
}

// SetSuiteID sets the suite_id field.
func (m *Oauth2ThirdMutation) SetSuiteID(s string) {
	m.suite_id = &s
}

// SuiteID returns the suite_id value in the mutation.
func (m *Oauth2ThirdMutation) SuiteID() (r string, exists bool) {
	v := m.suite_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSuiteID returns the old suite_id value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldSuiteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuiteID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuiteID: %w", err)
	}
	return oldValue.SuiteID, nil
}

// ResetSuiteID reset all changes of the "suite_id" field.
func (m *Oauth2ThirdMutation) ResetSuiteID() {
	m.suite_id = nil
}

// SetAppID sets the app_id field.
func (m *Oauth2ThirdMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the app_id value in the mutation.
func (m *Oauth2ThirdMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old app_id value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID reset all changes of the "app_id" field.
func (m *Oauth2ThirdMutation) ResetAppID() {
	m.app_id = nil
}

// SetAppSecret sets the app_secret field.
func (m *Oauth2ThirdMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the app_secret value in the mutation.
func (m *Oauth2ThirdMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old app_secret value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppSecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ResetAppSecret reset all changes of the "app_secret" field.
func (m *Oauth2ThirdMutation) ResetAppSecret() {
	m.app_secret = nil
}

// SetAuthorizeURL sets the authorize_url field.
func (m *Oauth2ThirdMutation) SetAuthorizeURL(s string) {
	m.authorize_url = &s
}

// AuthorizeURL returns the authorize_url value in the mutation.
func (m *Oauth2ThirdMutation) AuthorizeURL() (r string, exists bool) {
	v := m.authorize_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizeURL returns the old authorize_url value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldAuthorizeURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthorizeURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthorizeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizeURL: %w", err)
	}
	return oldValue.AuthorizeURL, nil
}

// ResetAuthorizeURL reset all changes of the "authorize_url" field.
func (m *Oauth2ThirdMutation) ResetAuthorizeURL() {
	m.authorize_url = nil
}

// SetTokenURL sets the token_url field.
func (m *Oauth2ThirdMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the token_url value in the mutation.
func (m *Oauth2ThirdMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old token_url value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTokenURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ResetTokenURL reset all changes of the "token_url" field.
func (m *Oauth2ThirdMutation) ResetTokenURL() {
	m.token_url = nil
}

// SetProfileURL sets the profile_url field.
func (m *Oauth2ThirdMutation) SetProfileURL(s string) {
	m.profile_url = &s
}

// ProfileURL returns the profile_url value in the mutation.
func (m *Oauth2ThirdMutation) ProfileURL() (r string, exists bool) {
	v := m.profile_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileURL returns the old profile_url value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldProfileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileURL: %w", err)
	}
	return oldValue.ProfileURL, nil
}

// ResetProfileURL reset all changes of the "profile_url" field.
func (m *Oauth2ThirdMutation) ResetProfileURL() {
	m.profile_url = nil
}

// SetDomainDef sets the domain_def field.
func (m *Oauth2ThirdMutation) SetDomainDef(s string) {
	m.domain_def = &s
}

// DomainDef returns the domain_def value in the mutation.
func (m *Oauth2ThirdMutation) DomainDef() (r string, exists bool) {
	v := m.domain_def
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainDef returns the old domain_def value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldDomainDef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDomainDef is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDomainDef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainDef: %w", err)
	}
	return oldValue.DomainDef, nil
}

// ResetDomainDef reset all changes of the "domain_def" field.
func (m *Oauth2ThirdMutation) ResetDomainDef() {
	m.domain_def = nil
}

// SetDomainCheck sets the domain_check field.
func (m *Oauth2ThirdMutation) SetDomainCheck(s string) {
	m.domain_check = &s
}

// DomainCheck returns the domain_check value in the mutation.
func (m *Oauth2ThirdMutation) DomainCheck() (r string, exists bool) {
	v := m.domain_check
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainCheck returns the old domain_check value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldDomainCheck(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDomainCheck is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDomainCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainCheck: %w", err)
	}
	return oldValue.DomainCheck, nil
}

// ResetDomainCheck reset all changes of the "domain_check" field.
func (m *Oauth2ThirdMutation) ResetDomainCheck() {
	m.domain_check = nil
}

// SetJsSecret sets the js_secret field.
func (m *Oauth2ThirdMutation) SetJsSecret(s string) {
	m.js_secret = &s
}

// JsSecret returns the js_secret value in the mutation.
func (m *Oauth2ThirdMutation) JsSecret() (r string, exists bool) {
	v := m.js_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldJsSecret returns the old js_secret value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldJsSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJsSecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJsSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJsSecret: %w", err)
	}
	return oldValue.JsSecret, nil
}

// ResetJsSecret reset all changes of the "js_secret" field.
func (m *Oauth2ThirdMutation) ResetJsSecret() {
	m.js_secret = nil
}

// SetStateSecret sets the state_secret field.
func (m *Oauth2ThirdMutation) SetStateSecret(s string) {
	m.state_secret = &s
}

// StateSecret returns the state_secret value in the mutation.
func (m *Oauth2ThirdMutation) StateSecret() (r string, exists bool) {
	v := m.state_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldStateSecret returns the old state_secret value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldStateSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStateSecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStateSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateSecret: %w", err)
	}
	return oldValue.StateSecret, nil
}

// ResetStateSecret reset all changes of the "state_secret" field.
func (m *Oauth2ThirdMutation) ResetStateSecret() {
	m.state_secret = nil
}

// SetCallback sets the callback field.
func (m *Oauth2ThirdMutation) SetCallback(i int) {
	m.callback = &i
	m.addcallback = nil
}

// Callback returns the callback value in the mutation.
func (m *Oauth2ThirdMutation) Callback() (r int, exists bool) {
	v := m.callback
	if v == nil {
		return
	}
	return *v, true
}

// OldCallback returns the old callback value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldCallback(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCallback is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallback: %w", err)
	}
	return oldValue.Callback, nil
}

// AddCallback adds i to callback.
func (m *Oauth2ThirdMutation) AddCallback(i int) {
	if m.addcallback != nil {
		*m.addcallback += i
	} else {
		m.addcallback = &i
	}
}

// AddedCallback returns the value that was added to the callback field in this mutation.
func (m *Oauth2ThirdMutation) AddedCallback() (r int, exists bool) {
	v := m.addcallback
	if v == nil {
		return
	}
	return *v, true
}

// ResetCallback reset all changes of the "callback" field.
func (m *Oauth2ThirdMutation) ResetCallback() {
	m.callback = nil
	m.addcallback = nil
}

// SetCbEncrypt sets the cb_encrypt field.
func (m *Oauth2ThirdMutation) SetCbEncrypt(i int) {
	m.cb_encrypt = &i
	m.addcb_encrypt = nil
}

// CbEncrypt returns the cb_encrypt value in the mutation.
func (m *Oauth2ThirdMutation) CbEncrypt() (r int, exists bool) {
	v := m.cb_encrypt
	if v == nil {
		return
	}
	return *v, true
}

// OldCbEncrypt returns the old cb_encrypt value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldCbEncrypt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCbEncrypt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCbEncrypt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbEncrypt: %w", err)
	}
	return oldValue.CbEncrypt, nil
}

// AddCbEncrypt adds i to cb_encrypt.
func (m *Oauth2ThirdMutation) AddCbEncrypt(i int) {
	if m.addcb_encrypt != nil {
		*m.addcb_encrypt += i
	} else {
		m.addcb_encrypt = &i
	}
}

// AddedCbEncrypt returns the value that was added to the cb_encrypt field in this mutation.
func (m *Oauth2ThirdMutation) AddedCbEncrypt() (r int, exists bool) {
	v := m.addcb_encrypt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCbEncrypt reset all changes of the "cb_encrypt" field.
func (m *Oauth2ThirdMutation) ResetCbEncrypt() {
	m.cb_encrypt = nil
	m.addcb_encrypt = nil
}

// SetCbToken sets the cb_token field.
func (m *Oauth2ThirdMutation) SetCbToken(s string) {
	m.cb_token = &s
}

// CbToken returns the cb_token value in the mutation.
func (m *Oauth2ThirdMutation) CbToken() (r string, exists bool) {
	v := m.cb_token
	if v == nil {
		return
	}
	return *v, true
}

// OldCbToken returns the old cb_token value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldCbToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCbToken is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCbToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbToken: %w", err)
	}
	return oldValue.CbToken, nil
}

// ResetCbToken reset all changes of the "cb_token" field.
func (m *Oauth2ThirdMutation) ResetCbToken() {
	m.cb_token = nil
}

// SetCbEncoding sets the cb_encoding field.
func (m *Oauth2ThirdMutation) SetCbEncoding(s string) {
	m.cb_encoding = &s
}

// CbEncoding returns the cb_encoding value in the mutation.
func (m *Oauth2ThirdMutation) CbEncoding() (r string, exists bool) {
	v := m.cb_encoding
	if v == nil {
		return
	}
	return *v, true
}

// OldCbEncoding returns the old cb_encoding value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldCbEncoding(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCbEncoding is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCbEncoding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbEncoding: %w", err)
	}
	return oldValue.CbEncoding, nil
}

// ResetCbEncoding reset all changes of the "cb_encoding" field.
func (m *Oauth2ThirdMutation) ResetCbEncoding() {
	m.cb_encoding = nil
}

// SetCreator sets the creator field.
func (m *Oauth2ThirdMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *Oauth2ThirdMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *Oauth2ThirdMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *Oauth2ThirdMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *Oauth2ThirdMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *Oauth2ThirdMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *Oauth2ThirdMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *Oauth2ThirdMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *Oauth2ThirdMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *Oauth2ThirdMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *Oauth2ThirdMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *Oauth2ThirdMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *Oauth2ThirdMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *Oauth2ThirdMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the string_1 field.
func (m *Oauth2ThirdMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the string_1 value in the mutation.
func (m *Oauth2ThirdMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old string_1 value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 reset all changes of the "string_1" field.
func (m *Oauth2ThirdMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the string_2 field.
func (m *Oauth2ThirdMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the string_2 value in the mutation.
func (m *Oauth2ThirdMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old string_2 value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 reset all changes of the "string_2" field.
func (m *Oauth2ThirdMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the string_3 field.
func (m *Oauth2ThirdMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the string_3 value in the mutation.
func (m *Oauth2ThirdMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old string_3 value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 reset all changes of the "string_3" field.
func (m *Oauth2ThirdMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the number_1 field.
func (m *Oauth2ThirdMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the number_1 value in the mutation.
func (m *Oauth2ThirdMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old number_1 value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to number_1.
func (m *Oauth2ThirdMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the number_1 field in this mutation.
func (m *Oauth2ThirdMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 reset all changes of the "number_1" field.
func (m *Oauth2ThirdMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the number_2 field.
func (m *Oauth2ThirdMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the number_2 value in the mutation.
func (m *Oauth2ThirdMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old number_2 value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to number_2.
func (m *Oauth2ThirdMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the number_2 field in this mutation.
func (m *Oauth2ThirdMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 reset all changes of the "number_2" field.
func (m *Oauth2ThirdMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the number_3 field.
func (m *Oauth2ThirdMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the number_3 value in the mutation.
func (m *Oauth2ThirdMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old number_3 value of the Oauth2Third.
// If the Oauth2Third object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2ThirdMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to number_3.
func (m *Oauth2ThirdMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the number_3 field in this mutation.
func (m *Oauth2ThirdMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 reset all changes of the "number_3" field.
func (m *Oauth2ThirdMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *Oauth2ThirdMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Oauth2Third).
func (m *Oauth2ThirdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *Oauth2ThirdMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.platform != nil {
		fields = append(fields, oauth2third.FieldPlatform)
	}
	if m.agent_id != nil {
		fields = append(fields, oauth2third.FieldAgentID)
	}
	if m.suite_id != nil {
		fields = append(fields, oauth2third.FieldSuiteID)
	}
	if m.app_id != nil {
		fields = append(fields, oauth2third.FieldAppID)
	}
	if m.app_secret != nil {
		fields = append(fields, oauth2third.FieldAppSecret)
	}
	if m.authorize_url != nil {
		fields = append(fields, oauth2third.FieldAuthorizeURL)
	}
	if m.token_url != nil {
		fields = append(fields, oauth2third.FieldTokenURL)
	}
	if m.profile_url != nil {
		fields = append(fields, oauth2third.FieldProfileURL)
	}
	if m.domain_def != nil {
		fields = append(fields, oauth2third.FieldDomainDef)
	}
	if m.domain_check != nil {
		fields = append(fields, oauth2third.FieldDomainCheck)
	}
	if m.js_secret != nil {
		fields = append(fields, oauth2third.FieldJsSecret)
	}
	if m.state_secret != nil {
		fields = append(fields, oauth2third.FieldStateSecret)
	}
	if m.callback != nil {
		fields = append(fields, oauth2third.FieldCallback)
	}
	if m.cb_encrypt != nil {
		fields = append(fields, oauth2third.FieldCbEncrypt)
	}
	if m.cb_token != nil {
		fields = append(fields, oauth2third.FieldCbToken)
	}
	if m.cb_encoding != nil {
		fields = append(fields, oauth2third.FieldCbEncoding)
	}
	if m.creator != nil {
		fields = append(fields, oauth2third.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, oauth2third.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2third.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, oauth2third.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, oauth2third.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, oauth2third.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, oauth2third.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, oauth2third.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, oauth2third.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, oauth2third.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *Oauth2ThirdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2third.FieldPlatform:
		return m.Platform()
	case oauth2third.FieldAgentID:
		return m.AgentID()
	case oauth2third.FieldSuiteID:
		return m.SuiteID()
	case oauth2third.FieldAppID:
		return m.AppID()
	case oauth2third.FieldAppSecret:
		return m.AppSecret()
	case oauth2third.FieldAuthorizeURL:
		return m.AuthorizeURL()
	case oauth2third.FieldTokenURL:
		return m.TokenURL()
	case oauth2third.FieldProfileURL:
		return m.ProfileURL()
	case oauth2third.FieldDomainDef:
		return m.DomainDef()
	case oauth2third.FieldDomainCheck:
		return m.DomainCheck()
	case oauth2third.FieldJsSecret:
		return m.JsSecret()
	case oauth2third.FieldStateSecret:
		return m.StateSecret()
	case oauth2third.FieldCallback:
		return m.Callback()
	case oauth2third.FieldCbEncrypt:
		return m.CbEncrypt()
	case oauth2third.FieldCbToken:
		return m.CbToken()
	case oauth2third.FieldCbEncoding:
		return m.CbEncoding()
	case oauth2third.FieldCreator:
		return m.Creator()
	case oauth2third.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2third.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2third.FieldVersion:
		return m.Version()
	case oauth2third.FieldString1:
		return m.String1()
	case oauth2third.FieldString2:
		return m.String2()
	case oauth2third.FieldString3:
		return m.String3()
	case oauth2third.FieldNumber1:
		return m.Number1()
	case oauth2third.FieldNumber2:
		return m.Number2()
	case oauth2third.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *Oauth2ThirdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2third.FieldPlatform:
		return m.OldPlatform(ctx)
	case oauth2third.FieldAgentID:
		return m.OldAgentID(ctx)
	case oauth2third.FieldSuiteID:
		return m.OldSuiteID(ctx)
	case oauth2third.FieldAppID:
		return m.OldAppID(ctx)
	case oauth2third.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case oauth2third.FieldAuthorizeURL:
		return m.OldAuthorizeURL(ctx)
	case oauth2third.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case oauth2third.FieldProfileURL:
		return m.OldProfileURL(ctx)
	case oauth2third.FieldDomainDef:
		return m.OldDomainDef(ctx)
	case oauth2third.FieldDomainCheck:
		return m.OldDomainCheck(ctx)
	case oauth2third.FieldJsSecret:
		return m.OldJsSecret(ctx)
	case oauth2third.FieldStateSecret:
		return m.OldStateSecret(ctx)
	case oauth2third.FieldCallback:
		return m.OldCallback(ctx)
	case oauth2third.FieldCbEncrypt:
		return m.OldCbEncrypt(ctx)
	case oauth2third.FieldCbToken:
		return m.OldCbToken(ctx)
	case oauth2third.FieldCbEncoding:
		return m.OldCbEncoding(ctx)
	case oauth2third.FieldCreator:
		return m.OldCreator(ctx)
	case oauth2third.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2third.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2third.FieldVersion:
		return m.OldVersion(ctx)
	case oauth2third.FieldString1:
		return m.OldString1(ctx)
	case oauth2third.FieldString2:
		return m.OldString2(ctx)
	case oauth2third.FieldString3:
		return m.OldString3(ctx)
	case oauth2third.FieldNumber1:
		return m.OldNumber1(ctx)
	case oauth2third.FieldNumber2:
		return m.OldNumber2(ctx)
	case oauth2third.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2Third field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2ThirdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2third.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case oauth2third.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case oauth2third.FieldSuiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuiteID(v)
		return nil
	case oauth2third.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case oauth2third.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case oauth2third.FieldAuthorizeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizeURL(v)
		return nil
	case oauth2third.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case oauth2third.FieldProfileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileURL(v)
		return nil
	case oauth2third.FieldDomainDef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainDef(v)
		return nil
	case oauth2third.FieldDomainCheck:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainCheck(v)
		return nil
	case oauth2third.FieldJsSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJsSecret(v)
		return nil
	case oauth2third.FieldStateSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateSecret(v)
		return nil
	case oauth2third.FieldCallback:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallback(v)
		return nil
	case oauth2third.FieldCbEncrypt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbEncrypt(v)
		return nil
	case oauth2third.FieldCbToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbToken(v)
		return nil
	case oauth2third.FieldCbEncoding:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbEncoding(v)
		return nil
	case oauth2third.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case oauth2third.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2third.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2third.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case oauth2third.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case oauth2third.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case oauth2third.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case oauth2third.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case oauth2third.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case oauth2third.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Third field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *Oauth2ThirdMutation) AddedFields() []string {
	var fields []string
	if m.addcallback != nil {
		fields = append(fields, oauth2third.FieldCallback)
	}
	if m.addcb_encrypt != nil {
		fields = append(fields, oauth2third.FieldCbEncrypt)
	}
	if m.addversion != nil {
		fields = append(fields, oauth2third.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, oauth2third.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, oauth2third.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, oauth2third.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *Oauth2ThirdMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2third.FieldCallback:
		return m.AddedCallback()
	case oauth2third.FieldCbEncrypt:
		return m.AddedCbEncrypt()
	case oauth2third.FieldVersion:
		return m.AddedVersion()
	case oauth2third.FieldNumber1:
		return m.AddedNumber1()
	case oauth2third.FieldNumber2:
		return m.AddedNumber2()
	case oauth2third.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2ThirdMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2third.FieldCallback:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCallback(v)
		return nil
	case oauth2third.FieldCbEncrypt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCbEncrypt(v)
		return nil
	case oauth2third.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case oauth2third.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case oauth2third.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case oauth2third.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Third numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *Oauth2ThirdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *Oauth2ThirdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2ThirdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2Third nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *Oauth2ThirdMutation) ResetField(name string) error {
	switch name {
	case oauth2third.FieldPlatform:
		m.ResetPlatform()
		return nil
	case oauth2third.FieldAgentID:
		m.ResetAgentID()
		return nil
	case oauth2third.FieldSuiteID:
		m.ResetSuiteID()
		return nil
	case oauth2third.FieldAppID:
		m.ResetAppID()
		return nil
	case oauth2third.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case oauth2third.FieldAuthorizeURL:
		m.ResetAuthorizeURL()
		return nil
	case oauth2third.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case oauth2third.FieldProfileURL:
		m.ResetProfileURL()
		return nil
	case oauth2third.FieldDomainDef:
		m.ResetDomainDef()
		return nil
	case oauth2third.FieldDomainCheck:
		m.ResetDomainCheck()
		return nil
	case oauth2third.FieldJsSecret:
		m.ResetJsSecret()
		return nil
	case oauth2third.FieldStateSecret:
		m.ResetStateSecret()
		return nil
	case oauth2third.FieldCallback:
		m.ResetCallback()
		return nil
	case oauth2third.FieldCbEncrypt:
		m.ResetCbEncrypt()
		return nil
	case oauth2third.FieldCbToken:
		m.ResetCbToken()
		return nil
	case oauth2third.FieldCbEncoding:
		m.ResetCbEncoding()
		return nil
	case oauth2third.FieldCreator:
		m.ResetCreator()
		return nil
	case oauth2third.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2third.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2third.FieldVersion:
		m.ResetVersion()
		return nil
	case oauth2third.FieldString1:
		m.ResetString1()
		return nil
	case oauth2third.FieldString2:
		m.ResetString2()
		return nil
	case oauth2third.FieldString3:
		m.ResetString3()
		return nil
	case oauth2third.FieldNumber1:
		m.ResetNumber1()
		return nil
	case oauth2third.FieldNumber2:
		m.ResetNumber2()
		return nil
	case oauth2third.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown Oauth2Third field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *Oauth2ThirdMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *Oauth2ThirdMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *Oauth2ThirdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *Oauth2ThirdMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *Oauth2ThirdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *Oauth2ThirdMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *Oauth2ThirdMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Third unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *Oauth2ThirdMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Third edge %s", name)
}

// Oauth2TokenMutation represents an operation that mutate the Oauth2Tokens
// nodes in the graph.
type Oauth2TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	oauth2_id     *string
	access_token  *string
	expires_in    *string
	create_time   *string
	sync_lock     *int
	addsync_lock  *int
	call_count    *int
	addcall_count *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	string_1      *string
	string_2      *string
	string_3      *string
	number_1      *int
	addnumber_1   *int
	number_2      *int
	addnumber_2   *int
	number_3      *int
	addnumber_3   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Oauth2Token, error)
}

var _ ent.Mutation = (*Oauth2TokenMutation)(nil)

// oauth2tokenOption allows to manage the mutation configuration using functional options.
type oauth2tokenOption func(*Oauth2TokenMutation)

// newOauth2TokenMutation creates new mutation for $n.Name.
func newOauth2TokenMutation(c config, op Op, opts ...oauth2tokenOption) *Oauth2TokenMutation {
	m := &Oauth2TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2Token,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2TokenID sets the id field of the mutation.
func withOauth2TokenID(id int) oauth2tokenOption {
	return func(m *Oauth2TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2Token
		)
		m.oldValue = func(ctx context.Context) (*Oauth2Token, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2Token sets the old Oauth2Token of the mutation.
func withOauth2Token(node *Oauth2Token) oauth2tokenOption {
	return func(m *Oauth2TokenMutation) {
		m.oldValue = func(context.Context) (*Oauth2Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *Oauth2TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOauth2ID sets the oauth2_id field.
func (m *Oauth2TokenMutation) SetOauth2ID(s string) {
	m.oauth2_id = &s
}

// Oauth2ID returns the oauth2_id value in the mutation.
func (m *Oauth2TokenMutation) Oauth2ID() (r string, exists bool) {
	v := m.oauth2_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOauth2ID returns the old oauth2_id value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldOauth2ID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOauth2ID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOauth2ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauth2ID: %w", err)
	}
	return oldValue.Oauth2ID, nil
}

// ResetOauth2ID reset all changes of the "oauth2_id" field.
func (m *Oauth2TokenMutation) ResetOauth2ID() {
	m.oauth2_id = nil
}

// SetAccessToken sets the access_token field.
func (m *Oauth2TokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the access_token value in the mutation.
func (m *Oauth2TokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old access_token value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessToken is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken reset all changes of the "access_token" field.
func (m *Oauth2TokenMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetExpiresIn sets the expires_in field.
func (m *Oauth2TokenMutation) SetExpiresIn(s string) {
	m.expires_in = &s
}

// ExpiresIn returns the expires_in value in the mutation.
func (m *Oauth2TokenMutation) ExpiresIn() (r string, exists bool) {
	v := m.expires_in
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresIn returns the old expires_in value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldExpiresIn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiresIn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiresIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresIn: %w", err)
	}
	return oldValue.ExpiresIn, nil
}

// ResetExpiresIn reset all changes of the "expires_in" field.
func (m *Oauth2TokenMutation) ResetExpiresIn() {
	m.expires_in = nil
}

// SetCreateTime sets the create_time field.
func (m *Oauth2TokenMutation) SetCreateTime(s string) {
	m.create_time = &s
}

// CreateTime returns the create_time value in the mutation.
func (m *Oauth2TokenMutation) CreateTime() (r string, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldCreateTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *Oauth2TokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetSyncLock sets the sync_lock field.
func (m *Oauth2TokenMutation) SetSyncLock(i int) {
	m.sync_lock = &i
	m.addsync_lock = nil
}

// SyncLock returns the sync_lock value in the mutation.
func (m *Oauth2TokenMutation) SyncLock() (r int, exists bool) {
	v := m.sync_lock
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncLock returns the old sync_lock value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldSyncLock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSyncLock is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSyncLock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncLock: %w", err)
	}
	return oldValue.SyncLock, nil
}

// AddSyncLock adds i to sync_lock.
func (m *Oauth2TokenMutation) AddSyncLock(i int) {
	if m.addsync_lock != nil {
		*m.addsync_lock += i
	} else {
		m.addsync_lock = &i
	}
}

// AddedSyncLock returns the value that was added to the sync_lock field in this mutation.
func (m *Oauth2TokenMutation) AddedSyncLock() (r int, exists bool) {
	v := m.addsync_lock
	if v == nil {
		return
	}
	return *v, true
}

// ResetSyncLock reset all changes of the "sync_lock" field.
func (m *Oauth2TokenMutation) ResetSyncLock() {
	m.sync_lock = nil
	m.addsync_lock = nil
}

// SetCallCount sets the call_count field.
func (m *Oauth2TokenMutation) SetCallCount(i int) {
	m.call_count = &i
	m.addcall_count = nil
}

// CallCount returns the call_count value in the mutation.
func (m *Oauth2TokenMutation) CallCount() (r int, exists bool) {
	v := m.call_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCallCount returns the old call_count value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldCallCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCallCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCallCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallCount: %w", err)
	}
	return oldValue.CallCount, nil
}

// AddCallCount adds i to call_count.
func (m *Oauth2TokenMutation) AddCallCount(i int) {
	if m.addcall_count != nil {
		*m.addcall_count += i
	} else {
		m.addcall_count = &i
	}
}

// AddedCallCount returns the value that was added to the call_count field in this mutation.
func (m *Oauth2TokenMutation) AddedCallCount() (r int, exists bool) {
	v := m.addcall_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCallCount reset all changes of the "call_count" field.
func (m *Oauth2TokenMutation) ResetCallCount() {
	m.call_count = nil
	m.addcall_count = nil
}

// SetCreator sets the creator field.
func (m *Oauth2TokenMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *Oauth2TokenMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *Oauth2TokenMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *Oauth2TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *Oauth2TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *Oauth2TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *Oauth2TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *Oauth2TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *Oauth2TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *Oauth2TokenMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *Oauth2TokenMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *Oauth2TokenMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *Oauth2TokenMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *Oauth2TokenMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the string_1 field.
func (m *Oauth2TokenMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the string_1 value in the mutation.
func (m *Oauth2TokenMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old string_1 value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 reset all changes of the "string_1" field.
func (m *Oauth2TokenMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the string_2 field.
func (m *Oauth2TokenMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the string_2 value in the mutation.
func (m *Oauth2TokenMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old string_2 value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 reset all changes of the "string_2" field.
func (m *Oauth2TokenMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the string_3 field.
func (m *Oauth2TokenMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the string_3 value in the mutation.
func (m *Oauth2TokenMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old string_3 value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 reset all changes of the "string_3" field.
func (m *Oauth2TokenMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the number_1 field.
func (m *Oauth2TokenMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the number_1 value in the mutation.
func (m *Oauth2TokenMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old number_1 value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to number_1.
func (m *Oauth2TokenMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the number_1 field in this mutation.
func (m *Oauth2TokenMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 reset all changes of the "number_1" field.
func (m *Oauth2TokenMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the number_2 field.
func (m *Oauth2TokenMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the number_2 value in the mutation.
func (m *Oauth2TokenMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old number_2 value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to number_2.
func (m *Oauth2TokenMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the number_2 field in this mutation.
func (m *Oauth2TokenMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 reset all changes of the "number_2" field.
func (m *Oauth2TokenMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the number_3 field.
func (m *Oauth2TokenMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the number_3 value in the mutation.
func (m *Oauth2TokenMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old number_3 value of the Oauth2Token.
// If the Oauth2Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *Oauth2TokenMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to number_3.
func (m *Oauth2TokenMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the number_3 field in this mutation.
func (m *Oauth2TokenMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 reset all changes of the "number_3" field.
func (m *Oauth2TokenMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *Oauth2TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Oauth2Token).
func (m *Oauth2TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *Oauth2TokenMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.oauth2_id != nil {
		fields = append(fields, oauth2token.FieldOauth2ID)
	}
	if m.access_token != nil {
		fields = append(fields, oauth2token.FieldAccessToken)
	}
	if m.expires_in != nil {
		fields = append(fields, oauth2token.FieldExpiresIn)
	}
	if m.create_time != nil {
		fields = append(fields, oauth2token.FieldCreateTime)
	}
	if m.sync_lock != nil {
		fields = append(fields, oauth2token.FieldSyncLock)
	}
	if m.call_count != nil {
		fields = append(fields, oauth2token.FieldCallCount)
	}
	if m.creator != nil {
		fields = append(fields, oauth2token.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, oauth2token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2token.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, oauth2token.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, oauth2token.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, oauth2token.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, oauth2token.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, oauth2token.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, oauth2token.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, oauth2token.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *Oauth2TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2token.FieldOauth2ID:
		return m.Oauth2ID()
	case oauth2token.FieldAccessToken:
		return m.AccessToken()
	case oauth2token.FieldExpiresIn:
		return m.ExpiresIn()
	case oauth2token.FieldCreateTime:
		return m.CreateTime()
	case oauth2token.FieldSyncLock:
		return m.SyncLock()
	case oauth2token.FieldCallCount:
		return m.CallCount()
	case oauth2token.FieldCreator:
		return m.Creator()
	case oauth2token.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2token.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2token.FieldVersion:
		return m.Version()
	case oauth2token.FieldString1:
		return m.String1()
	case oauth2token.FieldString2:
		return m.String2()
	case oauth2token.FieldString3:
		return m.String3()
	case oauth2token.FieldNumber1:
		return m.Number1()
	case oauth2token.FieldNumber2:
		return m.Number2()
	case oauth2token.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *Oauth2TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2token.FieldOauth2ID:
		return m.OldOauth2ID(ctx)
	case oauth2token.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case oauth2token.FieldExpiresIn:
		return m.OldExpiresIn(ctx)
	case oauth2token.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case oauth2token.FieldSyncLock:
		return m.OldSyncLock(ctx)
	case oauth2token.FieldCallCount:
		return m.OldCallCount(ctx)
	case oauth2token.FieldCreator:
		return m.OldCreator(ctx)
	case oauth2token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2token.FieldVersion:
		return m.OldVersion(ctx)
	case oauth2token.FieldString1:
		return m.OldString1(ctx)
	case oauth2token.FieldString2:
		return m.OldString2(ctx)
	case oauth2token.FieldString3:
		return m.OldString3(ctx)
	case oauth2token.FieldNumber1:
		return m.OldNumber1(ctx)
	case oauth2token.FieldNumber2:
		return m.OldNumber2(ctx)
	case oauth2token.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2Token field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2token.FieldOauth2ID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauth2ID(v)
		return nil
	case oauth2token.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case oauth2token.FieldExpiresIn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresIn(v)
		return nil
	case oauth2token.FieldCreateTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case oauth2token.FieldSyncLock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncLock(v)
		return nil
	case oauth2token.FieldCallCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallCount(v)
		return nil
	case oauth2token.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case oauth2token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2token.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case oauth2token.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case oauth2token.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case oauth2token.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case oauth2token.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case oauth2token.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case oauth2token.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *Oauth2TokenMutation) AddedFields() []string {
	var fields []string
	if m.addsync_lock != nil {
		fields = append(fields, oauth2token.FieldSyncLock)
	}
	if m.addcall_count != nil {
		fields = append(fields, oauth2token.FieldCallCount)
	}
	if m.addversion != nil {
		fields = append(fields, oauth2token.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, oauth2token.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, oauth2token.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, oauth2token.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *Oauth2TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2token.FieldSyncLock:
		return m.AddedSyncLock()
	case oauth2token.FieldCallCount:
		return m.AddedCallCount()
	case oauth2token.FieldVersion:
		return m.AddedVersion()
	case oauth2token.FieldNumber1:
		return m.AddedNumber1()
	case oauth2token.FieldNumber2:
		return m.AddedNumber2()
	case oauth2token.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *Oauth2TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2token.FieldSyncLock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSyncLock(v)
		return nil
	case oauth2token.FieldCallCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCallCount(v)
		return nil
	case oauth2token.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case oauth2token.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case oauth2token.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case oauth2token.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *Oauth2TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *Oauth2TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2Token nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *Oauth2TokenMutation) ResetField(name string) error {
	switch name {
	case oauth2token.FieldOauth2ID:
		m.ResetOauth2ID()
		return nil
	case oauth2token.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case oauth2token.FieldExpiresIn:
		m.ResetExpiresIn()
		return nil
	case oauth2token.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case oauth2token.FieldSyncLock:
		m.ResetSyncLock()
		return nil
	case oauth2token.FieldCallCount:
		m.ResetCallCount()
		return nil
	case oauth2token.FieldCreator:
		m.ResetCreator()
		return nil
	case oauth2token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2token.FieldVersion:
		m.ResetVersion()
		return nil
	case oauth2token.FieldString1:
		m.ResetString1()
		return nil
	case oauth2token.FieldString2:
		m.ResetString2()
		return nil
	case oauth2token.FieldString3:
		m.ResetString3()
		return nil
	case oauth2token.FieldNumber1:
		m.ResetNumber1()
		return nil
	case oauth2token.FieldNumber2:
		m.ResetNumber2()
		return nil
	case oauth2token.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown Oauth2Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *Oauth2TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *Oauth2TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *Oauth2TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *Oauth2TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *Oauth2TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *Oauth2TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *Oauth2TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Token unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *Oauth2TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Token edge %s", name)
}

// ResourceMutation represents an operation that mutate the Resources
// nodes in the graph.
type ResourceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	resource      *string
	path          *string
	netmask       *string
	allow         *int
	addallow      *int
	desc          *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Resource, error)
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows to manage the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for $n.Name.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the id field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetResource sets the resource field.
func (m *ResourceMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the resource value in the mutation.
func (m *ResourceMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old resource value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource reset all changes of the "resource" field.
func (m *ResourceMutation) ResetResource() {
	m.resource = nil
}

// SetPath sets the path field.
func (m *ResourceMutation) SetPath(s string) {
	m.path = &s
}

// Path returns the path value in the mutation.
func (m *ResourceMutation) Path() (r string, exists bool) {
	v := m.path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old path value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath reset all changes of the "path" field.
func (m *ResourceMutation) ResetPath() {
	m.path = nil
}

// SetNetmask sets the netmask field.
func (m *ResourceMutation) SetNetmask(s string) {
	m.netmask = &s
}

// Netmask returns the netmask value in the mutation.
func (m *ResourceMutation) Netmask() (r string, exists bool) {
	v := m.netmask
	if v == nil {
		return
	}
	return *v, true
}

// OldNetmask returns the old netmask value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldNetmask(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetmask is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetmask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetmask: %w", err)
	}
	return oldValue.Netmask, nil
}

// ResetNetmask reset all changes of the "netmask" field.
func (m *ResourceMutation) ResetNetmask() {
	m.netmask = nil
}

// SetAllow sets the allow field.
func (m *ResourceMutation) SetAllow(i int) {
	m.allow = &i
	m.addallow = nil
}

// Allow returns the allow value in the mutation.
func (m *ResourceMutation) Allow() (r int, exists bool) {
	v := m.allow
	if v == nil {
		return
	}
	return *v, true
}

// OldAllow returns the old allow value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldAllow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllow is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllow: %w", err)
	}
	return oldValue.Allow, nil
}

// AddAllow adds i to allow.
func (m *ResourceMutation) AddAllow(i int) {
	if m.addallow != nil {
		*m.addallow += i
	} else {
		m.addallow = &i
	}
}

// AddedAllow returns the value that was added to the allow field in this mutation.
func (m *ResourceMutation) AddedAllow() (r int, exists bool) {
	v := m.addallow
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllow reset all changes of the "allow" field.
func (m *ResourceMutation) ResetAllow() {
	m.allow = nil
	m.addallow = nil
}

// SetDesc sets the desc field.
func (m *ResourceMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the desc value in the mutation.
func (m *ResourceMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old desc value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc reset all changes of the "desc" field.
func (m *ResourceMutation) ResetDesc() {
	m.desc = nil
}

// SetCreator sets the creator field.
func (m *ResourceMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *ResourceMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *ResourceMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *ResourceMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *ResourceMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *ResourceMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *ResourceMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *ResourceMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.resource != nil {
		fields = append(fields, resource.FieldResource)
	}
	if m.path != nil {
		fields = append(fields, resource.FieldPath)
	}
	if m.netmask != nil {
		fields = append(fields, resource.FieldNetmask)
	}
	if m.allow != nil {
		fields = append(fields, resource.FieldAllow)
	}
	if m.desc != nil {
		fields = append(fields, resource.FieldDesc)
	}
	if m.creator != nil {
		fields = append(fields, resource.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, resource.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldResource:
		return m.Resource()
	case resource.FieldPath:
		return m.Path()
	case resource.FieldNetmask:
		return m.Netmask()
	case resource.FieldAllow:
		return m.Allow()
	case resource.FieldDesc:
		return m.Desc()
	case resource.FieldCreator:
		return m.Creator()
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldResource:
		return m.OldResource(ctx)
	case resource.FieldPath:
		return m.OldPath(ctx)
	case resource.FieldNetmask:
		return m.OldNetmask(ctx)
	case resource.FieldAllow:
		return m.OldAllow(ctx)
	case resource.FieldDesc:
		return m.OldDesc(ctx)
	case resource.FieldCreator:
		return m.OldCreator(ctx)
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case resource.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case resource.FieldNetmask:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetmask(v)
		return nil
	case resource.FieldAllow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllow(v)
		return nil
	case resource.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case resource.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResourceMutation) AddedFields() []string {
	var fields []string
	if m.addallow != nil {
		fields = append(fields, resource.FieldAllow)
	}
	if m.addversion != nil {
		fields = append(fields, resource.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldAllow:
		return m.AddedAllow()
	case resource.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resource.FieldAllow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllow(v)
		return nil
	case resource.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldResource:
		m.ResetResource()
		return nil
	case resource.FieldPath:
		m.ResetPath()
		return nil
	case resource.FieldNetmask:
		m.ResetNetmask()
		return nil
	case resource.FieldAllow:
		m.ResetAllow()
		return nil
	case resource.FieldDesc:
		m.ResetDesc()
		return nil
	case resource.FieldCreator:
		m.ResetCreator()
		return nil
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Resource edge %s", name)
}

// ResourceRoleMutation represents an operation that mutate the ResourceRoles
// nodes in the graph.
type ResourceRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role_id       *int
	addrole_id    *int
	resource      *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ResourceRole, error)
}

var _ ent.Mutation = (*ResourceRoleMutation)(nil)

// resourceroleOption allows to manage the mutation configuration using functional options.
type resourceroleOption func(*ResourceRoleMutation)

// newResourceRoleMutation creates new mutation for $n.Name.
func newResourceRoleMutation(c config, op Op, opts ...resourceroleOption) *ResourceRoleMutation {
	m := &ResourceRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceRoleID sets the id field of the mutation.
func withResourceRoleID(id int) resourceroleOption {
	return func(m *ResourceRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceRole
		)
		m.oldValue = func(ctx context.Context) (*ResourceRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceRole sets the old ResourceRole of the mutation.
func withResourceRole(node *ResourceRole) resourceroleOption {
	return func(m *ResourceRoleMutation) {
		m.oldValue = func(context.Context) (*ResourceRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResourceRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoleID sets the role_id field.
func (m *ResourceRoleMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the role_id value in the mutation.
func (m *ResourceRoleMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old role_id value of the ResourceRole.
// If the ResourceRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to role_id.
func (m *ResourceRoleMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the role_id field in this mutation.
func (m *ResourceRoleMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID reset all changes of the "role_id" field.
func (m *ResourceRoleMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetResource sets the resource field.
func (m *ResourceRoleMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the resource value in the mutation.
func (m *ResourceRoleMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old resource value of the ResourceRole.
// If the ResourceRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceRoleMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource reset all changes of the "resource" field.
func (m *ResourceRoleMutation) ResetResource() {
	m.resource = nil
}

// SetCreator sets the creator field.
func (m *ResourceRoleMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *ResourceRoleMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the ResourceRole.
// If the ResourceRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceRoleMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *ResourceRoleMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *ResourceRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ResourceRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the ResourceRole.
// If the ResourceRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ResourceRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ResourceRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ResourceRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the ResourceRole.
// If the ResourceRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ResourceRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *ResourceRoleMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *ResourceRoleMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the ResourceRole.
// If the ResourceRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceRoleMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *ResourceRoleMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *ResourceRoleMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *ResourceRoleMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *ResourceRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResourceRole).
func (m *ResourceRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResourceRoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.role_id != nil {
		fields = append(fields, resourcerole.FieldRoleID)
	}
	if m.resource != nil {
		fields = append(fields, resourcerole.FieldResource)
	}
	if m.creator != nil {
		fields = append(fields, resourcerole.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, resourcerole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resourcerole.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, resourcerole.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResourceRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcerole.FieldRoleID:
		return m.RoleID()
	case resourcerole.FieldResource:
		return m.Resource()
	case resourcerole.FieldCreator:
		return m.Creator()
	case resourcerole.FieldCreatedAt:
		return m.CreatedAt()
	case resourcerole.FieldUpdatedAt:
		return m.UpdatedAt()
	case resourcerole.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResourceRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcerole.FieldRoleID:
		return m.OldRoleID(ctx)
	case resourcerole.FieldResource:
		return m.OldResource(ctx)
	case resourcerole.FieldCreator:
		return m.OldCreator(ctx)
	case resourcerole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resourcerole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resourcerole.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceRole field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcerole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case resourcerole.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case resourcerole.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case resourcerole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resourcerole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resourcerole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResourceRoleMutation) AddedFields() []string {
	var fields []string
	if m.addrole_id != nil {
		fields = append(fields, resourcerole.FieldRoleID)
	}
	if m.addversion != nil {
		fields = append(fields, resourcerole.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResourceRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourcerole.FieldRoleID:
		return m.AddedRoleID()
	case resourcerole.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourcerole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case resourcerole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResourceRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResourceRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceRole nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResourceRoleMutation) ResetField(name string) error {
	switch name {
	case resourcerole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case resourcerole.FieldResource:
		m.ResetResource()
		return nil
	case resourcerole.FieldCreator:
		m.ResetCreator()
		return nil
	case resourcerole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resourcerole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resourcerole.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown ResourceRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResourceRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResourceRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResourceRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResourceRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResourceRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResourceRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResourceRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResourceRole unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResourceRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResourceRole edge %s", name)
}

// ResourceUserMutation represents an operation that mutate the ResourceUsers
// nodes in the graph.
type ResourceUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	resource      *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ResourceUser, error)
}

var _ ent.Mutation = (*ResourceUserMutation)(nil)

// resourceuserOption allows to manage the mutation configuration using functional options.
type resourceuserOption func(*ResourceUserMutation)

// newResourceUserMutation creates new mutation for $n.Name.
func newResourceUserMutation(c config, op Op, opts ...resourceuserOption) *ResourceUserMutation {
	m := &ResourceUserMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceUserID sets the id field of the mutation.
func withResourceUserID(id int) resourceuserOption {
	return func(m *ResourceUserMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceUser
		)
		m.oldValue = func(ctx context.Context) (*ResourceUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceUser sets the old ResourceUser of the mutation.
func withResourceUser(node *ResourceUser) resourceuserOption {
	return func(m *ResourceUserMutation) {
		m.oldValue = func(context.Context) (*ResourceUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResourceUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the user_id field.
func (m *ResourceUserMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the user_id value in the mutation.
func (m *ResourceUserMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the ResourceUser.
// If the ResourceUser object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to user_id.
func (m *ResourceUserMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the user_id field in this mutation.
func (m *ResourceUserMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID reset all changes of the "user_id" field.
func (m *ResourceUserMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetResource sets the resource field.
func (m *ResourceUserMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the resource value in the mutation.
func (m *ResourceUserMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old resource value of the ResourceUser.
// If the ResourceUser object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceUserMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource reset all changes of the "resource" field.
func (m *ResourceUserMutation) ResetResource() {
	m.resource = nil
}

// SetCreator sets the creator field.
func (m *ResourceUserMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *ResourceUserMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the ResourceUser.
// If the ResourceUser object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceUserMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *ResourceUserMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *ResourceUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ResourceUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the ResourceUser.
// If the ResourceUser object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ResourceUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ResourceUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ResourceUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the ResourceUser.
// If the ResourceUser object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ResourceUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *ResourceUserMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *ResourceUserMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the ResourceUser.
// If the ResourceUser object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceUserMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *ResourceUserMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *ResourceUserMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *ResourceUserMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *ResourceUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResourceUser).
func (m *ResourceUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResourceUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, resourceuser.FieldUserID)
	}
	if m.resource != nil {
		fields = append(fields, resourceuser.FieldResource)
	}
	if m.creator != nil {
		fields = append(fields, resourceuser.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, resourceuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resourceuser.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, resourceuser.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResourceUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceuser.FieldUserID:
		return m.UserID()
	case resourceuser.FieldResource:
		return m.Resource()
	case resourceuser.FieldCreator:
		return m.Creator()
	case resourceuser.FieldCreatedAt:
		return m.CreatedAt()
	case resourceuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case resourceuser.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResourceUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceuser.FieldUserID:
		return m.OldUserID(ctx)
	case resourceuser.FieldResource:
		return m.OldResource(ctx)
	case resourceuser.FieldCreator:
		return m.OldCreator(ctx)
	case resourceuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resourceuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resourceuser.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceUser field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case resourceuser.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case resourceuser.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case resourceuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resourceuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resourceuser.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResourceUserMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, resourceuser.FieldUserID)
	}
	if m.addversion != nil {
		fields = append(fields, resourceuser.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResourceUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourceuser.FieldUserID:
		return m.AddedUserID()
	case resourceuser.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourceuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case resourceuser.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResourceUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResourceUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceUser nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResourceUserMutation) ResetField(name string) error {
	switch name {
	case resourceuser.FieldUserID:
		m.ResetUserID()
		return nil
	case resourceuser.FieldResource:
		m.ResetResource()
		return nil
	case resourceuser.FieldCreator:
		m.ResetCreator()
		return nil
	case resourceuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resourceuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resourceuser.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown ResourceUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResourceUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResourceUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResourceUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResourceUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResourceUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResourceUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResourceUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResourceUser unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResourceUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResourceUser edge %s", name)
}

// RoleMutation represents an operation that mutate the Roles
// nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uid           *string
	name          *string
	desc          *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows to manage the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for $n.Name.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the id field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUID sets the uid field.
func (m *RoleMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the uid value in the mutation.
func (m *RoleMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old uid value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID reset all changes of the "uid" field.
func (m *RoleMutation) ResetUID() {
	m.uid = nil
}

// SetName sets the name field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the desc field.
func (m *RoleMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the desc value in the mutation.
func (m *RoleMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old desc value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc reset all changes of the "desc" field.
func (m *RoleMutation) ResetDesc() {
	m.desc = nil
}

// SetCreator sets the creator field.
func (m *RoleMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *RoleMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *RoleMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *RoleMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *RoleMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *RoleMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *RoleMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *RoleMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, role.FieldUID)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, role.FieldDesc)
	}
	if m.creator != nil {
		fields = append(fields, role.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, role.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldUID:
		return m.UID()
	case role.FieldName:
		return m.Name()
	case role.FieldDesc:
		return m.Desc()
	case role.FieldCreator:
		return m.Creator()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldUID:
		return m.OldUID(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDesc:
		return m.OldDesc(ctx)
	case role.FieldCreator:
		return m.OldCreator(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case role.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, role.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldUID:
		m.ResetUID()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDesc:
		m.ResetDesc()
		return nil
	case role.FieldCreator:
		m.ResetCreator()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleRoleMutation represents an operation that mutate the RoleRoles
// nodes in the graph.
type RoleRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	owner_id      *int
	addowner_id   *int
	child_id      *int
	addchild_id   *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RoleRole, error)
}

var _ ent.Mutation = (*RoleRoleMutation)(nil)

// roleroleOption allows to manage the mutation configuration using functional options.
type roleroleOption func(*RoleRoleMutation)

// newRoleRoleMutation creates new mutation for $n.Name.
func newRoleRoleMutation(c config, op Op, opts ...roleroleOption) *RoleRoleMutation {
	m := &RoleRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleRoleID sets the id field of the mutation.
func withRoleRoleID(id int) roleroleOption {
	return func(m *RoleRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleRole
		)
		m.oldValue = func(ctx context.Context) (*RoleRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleRole sets the old RoleRole of the mutation.
func withRoleRole(node *RoleRole) roleroleOption {
	return func(m *RoleRoleMutation) {
		m.oldValue = func(context.Context) (*RoleRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOwnerID sets the owner_id field.
func (m *RoleRoleMutation) SetOwnerID(i int) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the owner_id value in the mutation.
func (m *RoleRoleMutation) OwnerID() (r int, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old owner_id value of the RoleRole.
// If the RoleRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleRoleMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to owner_id.
func (m *RoleRoleMutation) AddOwnerID(i int) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the owner_id field in this mutation.
func (m *RoleRoleMutation) AddedOwnerID() (r int, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID reset all changes of the "owner_id" field.
func (m *RoleRoleMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// SetChildID sets the child_id field.
func (m *RoleRoleMutation) SetChildID(i int) {
	m.child_id = &i
	m.addchild_id = nil
}

// ChildID returns the child_id value in the mutation.
func (m *RoleRoleMutation) ChildID() (r int, exists bool) {
	v := m.child_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildID returns the old child_id value of the RoleRole.
// If the RoleRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleRoleMutation) OldChildID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChildID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChildID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildID: %w", err)
	}
	return oldValue.ChildID, nil
}

// AddChildID adds i to child_id.
func (m *RoleRoleMutation) AddChildID(i int) {
	if m.addchild_id != nil {
		*m.addchild_id += i
	} else {
		m.addchild_id = &i
	}
}

// AddedChildID returns the value that was added to the child_id field in this mutation.
func (m *RoleRoleMutation) AddedChildID() (r int, exists bool) {
	v := m.addchild_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildID reset all changes of the "child_id" field.
func (m *RoleRoleMutation) ResetChildID() {
	m.child_id = nil
	m.addchild_id = nil
}

// SetCreator sets the creator field.
func (m *RoleRoleMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *RoleRoleMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the RoleRole.
// If the RoleRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleRoleMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *RoleRoleMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *RoleRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *RoleRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the RoleRole.
// If the RoleRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *RoleRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *RoleRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *RoleRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the RoleRole.
// If the RoleRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *RoleRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *RoleRoleMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *RoleRoleMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the RoleRole.
// If the RoleRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleRoleMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *RoleRoleMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *RoleRoleMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *RoleRoleMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *RoleRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RoleRole).
func (m *RoleRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleRoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner_id != nil {
		fields = append(fields, rolerole.FieldOwnerID)
	}
	if m.child_id != nil {
		fields = append(fields, rolerole.FieldChildID)
	}
	if m.creator != nil {
		fields = append(fields, rolerole.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, rolerole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rolerole.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, rolerole.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolerole.FieldOwnerID:
		return m.OwnerID()
	case rolerole.FieldChildID:
		return m.ChildID()
	case rolerole.FieldCreator:
		return m.Creator()
	case rolerole.FieldCreatedAt:
		return m.CreatedAt()
	case rolerole.FieldUpdatedAt:
		return m.UpdatedAt()
	case rolerole.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolerole.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case rolerole.FieldChildID:
		return m.OldChildID(ctx)
	case rolerole.FieldCreator:
		return m.OldCreator(ctx)
	case rolerole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rolerole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rolerole.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown RoleRole field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolerole.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case rolerole.FieldChildID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildID(v)
		return nil
	case rolerole.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case rolerole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rolerole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rolerole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RoleRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleRoleMutation) AddedFields() []string {
	var fields []string
	if m.addowner_id != nil {
		fields = append(fields, rolerole.FieldOwnerID)
	}
	if m.addchild_id != nil {
		fields = append(fields, rolerole.FieldChildID)
	}
	if m.addversion != nil {
		fields = append(fields, rolerole.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rolerole.FieldOwnerID:
		return m.AddedOwnerID()
	case rolerole.FieldChildID:
		return m.AddedChildID()
	case rolerole.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rolerole.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case rolerole.FieldChildID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildID(v)
		return nil
	case rolerole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RoleRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoleRole nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleRoleMutation) ResetField(name string) error {
	switch name {
	case rolerole.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case rolerole.FieldChildID:
		m.ResetChildID()
		return nil
	case rolerole.FieldCreator:
		m.ResetCreator()
		return nil
	case rolerole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rolerole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rolerole.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown RoleRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RoleRole unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RoleRole edge %s", name)
}

// TagCommonMutation represents an operation that mutate the TagCommons
// nodes in the graph.
type TagCommonMutation struct {
	config
	op            Op
	typ           string
	id            *int
	owner_id      *int
	addowner_id   *int
	_type         *int
	add_type      *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TagCommon, error)
}

var _ ent.Mutation = (*TagCommonMutation)(nil)

// tagcommonOption allows to manage the mutation configuration using functional options.
type tagcommonOption func(*TagCommonMutation)

// newTagCommonMutation creates new mutation for $n.Name.
func newTagCommonMutation(c config, op Op, opts ...tagcommonOption) *TagCommonMutation {
	m := &TagCommonMutation{
		config:        c,
		op:            op,
		typ:           TypeTagCommon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagCommonID sets the id field of the mutation.
func withTagCommonID(id int) tagcommonOption {
	return func(m *TagCommonMutation) {
		var (
			err   error
			once  sync.Once
			value *TagCommon
		)
		m.oldValue = func(ctx context.Context) (*TagCommon, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TagCommon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTagCommon sets the old TagCommon of the mutation.
func withTagCommon(node *TagCommon) tagcommonOption {
	return func(m *TagCommonMutation) {
		m.oldValue = func(context.Context) (*TagCommon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagCommonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagCommonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TagCommonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOwnerID sets the owner_id field.
func (m *TagCommonMutation) SetOwnerID(i int) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the owner_id value in the mutation.
func (m *TagCommonMutation) OwnerID() (r int, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old owner_id value of the TagCommon.
// If the TagCommon object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagCommonMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to owner_id.
func (m *TagCommonMutation) AddOwnerID(i int) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the owner_id field in this mutation.
func (m *TagCommonMutation) AddedOwnerID() (r int, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID reset all changes of the "owner_id" field.
func (m *TagCommonMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// SetType sets the type field.
func (m *TagCommonMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *TagCommonMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the TagCommon.
// If the TagCommon object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagCommonMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *TagCommonMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *TagCommonMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *TagCommonMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCreator sets the creator field.
func (m *TagCommonMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *TagCommonMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the TagCommon.
// If the TagCommon object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagCommonMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *TagCommonMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *TagCommonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *TagCommonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the TagCommon.
// If the TagCommon object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagCommonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *TagCommonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *TagCommonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *TagCommonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the TagCommon.
// If the TagCommon object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagCommonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *TagCommonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *TagCommonMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *TagCommonMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the TagCommon.
// If the TagCommon object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagCommonMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *TagCommonMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *TagCommonMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *TagCommonMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *TagCommonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TagCommon).
func (m *TagCommonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TagCommonMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner_id != nil {
		fields = append(fields, tagcommon.FieldOwnerID)
	}
	if m._type != nil {
		fields = append(fields, tagcommon.FieldType)
	}
	if m.creator != nil {
		fields = append(fields, tagcommon.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, tagcommon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tagcommon.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, tagcommon.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TagCommonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tagcommon.FieldOwnerID:
		return m.OwnerID()
	case tagcommon.FieldType:
		return m.GetType()
	case tagcommon.FieldCreator:
		return m.Creator()
	case tagcommon.FieldCreatedAt:
		return m.CreatedAt()
	case tagcommon.FieldUpdatedAt:
		return m.UpdatedAt()
	case tagcommon.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TagCommonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tagcommon.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case tagcommon.FieldType:
		return m.OldType(ctx)
	case tagcommon.FieldCreator:
		return m.OldCreator(ctx)
	case tagcommon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tagcommon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tagcommon.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown TagCommon field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagCommonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tagcommon.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case tagcommon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tagcommon.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case tagcommon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tagcommon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tagcommon.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown TagCommon field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TagCommonMutation) AddedFields() []string {
	var fields []string
	if m.addowner_id != nil {
		fields = append(fields, tagcommon.FieldOwnerID)
	}
	if m.add_type != nil {
		fields = append(fields, tagcommon.FieldType)
	}
	if m.addversion != nil {
		fields = append(fields, tagcommon.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TagCommonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tagcommon.FieldOwnerID:
		return m.AddedOwnerID()
	case tagcommon.FieldType:
		return m.AddedType()
	case tagcommon.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagCommonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tagcommon.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case tagcommon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case tagcommon.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown TagCommon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TagCommonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TagCommonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagCommonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TagCommon nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TagCommonMutation) ResetField(name string) error {
	switch name {
	case tagcommon.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case tagcommon.FieldType:
		m.ResetType()
		return nil
	case tagcommon.FieldCreator:
		m.ResetCreator()
		return nil
	case tagcommon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tagcommon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tagcommon.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown TagCommon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TagCommonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TagCommonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TagCommonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TagCommonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TagCommonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TagCommonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TagCommonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TagCommon unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TagCommonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TagCommon edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uid           *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUID sets the uid field.
func (m *UserMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the uid value in the mutation.
func (m *UserMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old uid value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID reset all changes of the "uid" field.
func (m *UserMutation) ResetUID() {
	m.uid = nil
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.uid != nil {
		fields = append(fields, user.FieldUID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUID:
		return m.UID()
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUID:
		return m.OldUID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUID:
		m.ResetUID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDetailMutation represents an operation that mutate the UserDetails
// nodes in the graph.
type UserDetailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	nickname      *string
	avatar        *string
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	string_1      *string
	string_2      *string
	string_3      *string
	number_1      *int
	addnumber_1   *int
	number_2      *int
	addnumber_2   *int
	number_3      *int
	addnumber_3   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserDetail, error)
}

var _ ent.Mutation = (*UserDetailMutation)(nil)

// userdetailOption allows to manage the mutation configuration using functional options.
type userdetailOption func(*UserDetailMutation)

// newUserDetailMutation creates new mutation for $n.Name.
func newUserDetailMutation(c config, op Op, opts ...userdetailOption) *UserDetailMutation {
	m := &UserDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDetailID sets the id field of the mutation.
func withUserDetailID(id int) userdetailOption {
	return func(m *UserDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDetail
		)
		m.oldValue = func(ctx context.Context) (*UserDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDetail sets the old UserDetail of the mutation.
func withUserDetail(node *UserDetail) userdetailOption {
	return func(m *UserDetailMutation) {
		m.oldValue = func(context.Context) (*UserDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the user_id field.
func (m *UserDetailMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the user_id value in the mutation.
func (m *UserDetailMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to user_id.
func (m *UserDetailMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the user_id field in this mutation.
func (m *UserDetailMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID reset all changes of the "user_id" field.
func (m *UserDetailMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetNickname sets the nickname field.
func (m *UserDetailMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the nickname value in the mutation.
func (m *UserDetailMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old nickname value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname reset all changes of the "nickname" field.
func (m *UserDetailMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the avatar field.
func (m *UserDetailMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the avatar value in the mutation.
func (m *UserDetailMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old avatar value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar reset all changes of the "avatar" field.
func (m *UserDetailMutation) ResetAvatar() {
	m.avatar = nil
}

// SetCreator sets the creator field.
func (m *UserDetailMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *UserDetailMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *UserDetailMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *UserDetailMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *UserDetailMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *UserDetailMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *UserDetailMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *UserDetailMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetString1 sets the string_1 field.
func (m *UserDetailMutation) SetString1(s string) {
	m.string_1 = &s
}

// String1 returns the string_1 value in the mutation.
func (m *UserDetailMutation) String1() (r string, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old string_1 value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldString1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// ResetString1 reset all changes of the "string_1" field.
func (m *UserDetailMutation) ResetString1() {
	m.string_1 = nil
}

// SetString2 sets the string_2 field.
func (m *UserDetailMutation) SetString2(s string) {
	m.string_2 = &s
}

// String2 returns the string_2 value in the mutation.
func (m *UserDetailMutation) String2() (r string, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old string_2 value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldString2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// ResetString2 reset all changes of the "string_2" field.
func (m *UserDetailMutation) ResetString2() {
	m.string_2 = nil
}

// SetString3 sets the string_3 field.
func (m *UserDetailMutation) SetString3(s string) {
	m.string_3 = &s
}

// String3 returns the string_3 value in the mutation.
func (m *UserDetailMutation) String3() (r string, exists bool) {
	v := m.string_3
	if v == nil {
		return
	}
	return *v, true
}

// OldString3 returns the old string_3 value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldString3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString3: %w", err)
	}
	return oldValue.String3, nil
}

// ResetString3 reset all changes of the "string_3" field.
func (m *UserDetailMutation) ResetString3() {
	m.string_3 = nil
}

// SetNumber1 sets the number_1 field.
func (m *UserDetailMutation) SetNumber1(i int) {
	m.number_1 = &i
	m.addnumber_1 = nil
}

// Number1 returns the number_1 value in the mutation.
func (m *UserDetailMutation) Number1() (r int, exists bool) {
	v := m.number_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber1 returns the old number_1 value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldNumber1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber1: %w", err)
	}
	return oldValue.Number1, nil
}

// AddNumber1 adds i to number_1.
func (m *UserDetailMutation) AddNumber1(i int) {
	if m.addnumber_1 != nil {
		*m.addnumber_1 += i
	} else {
		m.addnumber_1 = &i
	}
}

// AddedNumber1 returns the value that was added to the number_1 field in this mutation.
func (m *UserDetailMutation) AddedNumber1() (r int, exists bool) {
	v := m.addnumber_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber1 reset all changes of the "number_1" field.
func (m *UserDetailMutation) ResetNumber1() {
	m.number_1 = nil
	m.addnumber_1 = nil
}

// SetNumber2 sets the number_2 field.
func (m *UserDetailMutation) SetNumber2(i int) {
	m.number_2 = &i
	m.addnumber_2 = nil
}

// Number2 returns the number_2 value in the mutation.
func (m *UserDetailMutation) Number2() (r int, exists bool) {
	v := m.number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber2 returns the old number_2 value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldNumber2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber2: %w", err)
	}
	return oldValue.Number2, nil
}

// AddNumber2 adds i to number_2.
func (m *UserDetailMutation) AddNumber2(i int) {
	if m.addnumber_2 != nil {
		*m.addnumber_2 += i
	} else {
		m.addnumber_2 = &i
	}
}

// AddedNumber2 returns the value that was added to the number_2 field in this mutation.
func (m *UserDetailMutation) AddedNumber2() (r int, exists bool) {
	v := m.addnumber_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber2 reset all changes of the "number_2" field.
func (m *UserDetailMutation) ResetNumber2() {
	m.number_2 = nil
	m.addnumber_2 = nil
}

// SetNumber3 sets the number_3 field.
func (m *UserDetailMutation) SetNumber3(i int) {
	m.number_3 = &i
	m.addnumber_3 = nil
}

// Number3 returns the number_3 value in the mutation.
func (m *UserDetailMutation) Number3() (r int, exists bool) {
	v := m.number_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber3 returns the old number_3 value of the UserDetail.
// If the UserDetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserDetailMutation) OldNumber3(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber3: %w", err)
	}
	return oldValue.Number3, nil
}

// AddNumber3 adds i to number_3.
func (m *UserDetailMutation) AddNumber3(i int) {
	if m.addnumber_3 != nil {
		*m.addnumber_3 += i
	} else {
		m.addnumber_3 = &i
	}
}

// AddedNumber3 returns the value that was added to the number_3 field in this mutation.
func (m *UserDetailMutation) AddedNumber3() (r int, exists bool) {
	v := m.addnumber_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber3 reset all changes of the "number_3" field.
func (m *UserDetailMutation) ResetNumber3() {
	m.number_3 = nil
	m.addnumber_3 = nil
}

// Op returns the operation name.
func (m *UserDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserDetail).
func (m *UserDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserDetailMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user_id != nil {
		fields = append(fields, userdetail.FieldUserID)
	}
	if m.nickname != nil {
		fields = append(fields, userdetail.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, userdetail.FieldAvatar)
	}
	if m.creator != nil {
		fields = append(fields, userdetail.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, userdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userdetail.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, userdetail.FieldVersion)
	}
	if m.string_1 != nil {
		fields = append(fields, userdetail.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, userdetail.FieldString2)
	}
	if m.string_3 != nil {
		fields = append(fields, userdetail.FieldString3)
	}
	if m.number_1 != nil {
		fields = append(fields, userdetail.FieldNumber1)
	}
	if m.number_2 != nil {
		fields = append(fields, userdetail.FieldNumber2)
	}
	if m.number_3 != nil {
		fields = append(fields, userdetail.FieldNumber3)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdetail.FieldUserID:
		return m.UserID()
	case userdetail.FieldNickname:
		return m.Nickname()
	case userdetail.FieldAvatar:
		return m.Avatar()
	case userdetail.FieldCreator:
		return m.Creator()
	case userdetail.FieldCreatedAt:
		return m.CreatedAt()
	case userdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdetail.FieldVersion:
		return m.Version()
	case userdetail.FieldString1:
		return m.String1()
	case userdetail.FieldString2:
		return m.String2()
	case userdetail.FieldString3:
		return m.String3()
	case userdetail.FieldNumber1:
		return m.Number1()
	case userdetail.FieldNumber2:
		return m.Number2()
	case userdetail.FieldNumber3:
		return m.Number3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdetail.FieldUserID:
		return m.OldUserID(ctx)
	case userdetail.FieldNickname:
		return m.OldNickname(ctx)
	case userdetail.FieldAvatar:
		return m.OldAvatar(ctx)
	case userdetail.FieldCreator:
		return m.OldCreator(ctx)
	case userdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdetail.FieldVersion:
		return m.OldVersion(ctx)
	case userdetail.FieldString1:
		return m.OldString1(ctx)
	case userdetail.FieldString2:
		return m.OldString2(ctx)
	case userdetail.FieldString3:
		return m.OldString3(ctx)
	case userdetail.FieldNumber1:
		return m.OldNumber1(ctx)
	case userdetail.FieldNumber2:
		return m.OldNumber2(ctx)
	case userdetail.FieldNumber3:
		return m.OldNumber3(ctx)
	}
	return nil, fmt.Errorf("unknown UserDetail field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdetail.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdetail.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case userdetail.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case userdetail.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case userdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdetail.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case userdetail.FieldString1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case userdetail.FieldString2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	case userdetail.FieldString3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString3(v)
		return nil
	case userdetail.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber1(v)
		return nil
	case userdetail.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber2(v)
		return nil
	case userdetail.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown UserDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserDetailMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userdetail.FieldUserID)
	}
	if m.addversion != nil {
		fields = append(fields, userdetail.FieldVersion)
	}
	if m.addnumber_1 != nil {
		fields = append(fields, userdetail.FieldNumber1)
	}
	if m.addnumber_2 != nil {
		fields = append(fields, userdetail.FieldNumber2)
	}
	if m.addnumber_3 != nil {
		fields = append(fields, userdetail.FieldNumber3)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdetail.FieldUserID:
		return m.AddedUserID()
	case userdetail.FieldVersion:
		return m.AddedVersion()
	case userdetail.FieldNumber1:
		return m.AddedNumber1()
	case userdetail.FieldNumber2:
		return m.AddedNumber2()
	case userdetail.FieldNumber3:
		return m.AddedNumber3()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdetail.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userdetail.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case userdetail.FieldNumber1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber1(v)
		return nil
	case userdetail.FieldNumber2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber2(v)
		return nil
	case userdetail.FieldNumber3:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber3(v)
		return nil
	}
	return fmt.Errorf("unknown UserDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserDetailMutation) ResetField(name string) error {
	switch name {
	case userdetail.FieldUserID:
		m.ResetUserID()
		return nil
	case userdetail.FieldNickname:
		m.ResetNickname()
		return nil
	case userdetail.FieldAvatar:
		m.ResetAvatar()
		return nil
	case userdetail.FieldCreator:
		m.ResetCreator()
		return nil
	case userdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdetail.FieldVersion:
		m.ResetVersion()
		return nil
	case userdetail.FieldString1:
		m.ResetString1()
		return nil
	case userdetail.FieldString2:
		m.ResetString2()
		return nil
	case userdetail.FieldString3:
		m.ResetString3()
		return nil
	case userdetail.FieldNumber1:
		m.ResetNumber1()
		return nil
	case userdetail.FieldNumber2:
		m.ResetNumber2()
		return nil
	case userdetail.FieldNumber3:
		m.ResetNumber3()
		return nil
	}
	return fmt.Errorf("unknown UserDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserDetail unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserDetail edge %s", name)
}

// UserMessageMutation represents an operation that mutate the UserMessages
// nodes in the graph.
type UserMessageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uid           *string
	avatar        *string
	title         *string
	datetime      *string
	_type         *string
	read          *int
	addread       *int
	description   *string
	clickClose    *int
	addclickClose *int
	status        *int
	addstatus     *int
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserMessage, error)
}

var _ ent.Mutation = (*UserMessageMutation)(nil)

// usermessageOption allows to manage the mutation configuration using functional options.
type usermessageOption func(*UserMessageMutation)

// newUserMessageMutation creates new mutation for $n.Name.
func newUserMessageMutation(c config, op Op, opts ...usermessageOption) *UserMessageMutation {
	m := &UserMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserMessageID sets the id field of the mutation.
func withUserMessageID(id int) usermessageOption {
	return func(m *UserMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *UserMessage
		)
		m.oldValue = func(ctx context.Context) (*UserMessage, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserMessage sets the old UserMessage of the mutation.
func withUserMessage(node *UserMessage) usermessageOption {
	return func(m *UserMessageMutation) {
		m.oldValue = func(context.Context) (*UserMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUID sets the uid field.
func (m *UserMessageMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the uid value in the mutation.
func (m *UserMessageMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old uid value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID reset all changes of the "uid" field.
func (m *UserMessageMutation) ResetUID() {
	m.uid = nil
}

// SetAvatar sets the avatar field.
func (m *UserMessageMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the avatar value in the mutation.
func (m *UserMessageMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old avatar value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar reset all changes of the "avatar" field.
func (m *UserMessageMutation) ResetAvatar() {
	m.avatar = nil
}

// SetTitle sets the title field.
func (m *UserMessageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *UserMessageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *UserMessageMutation) ResetTitle() {
	m.title = nil
}

// SetDatetime sets the datetime field.
func (m *UserMessageMutation) SetDatetime(s string) {
	m.datetime = &s
}

// Datetime returns the datetime value in the mutation.
func (m *UserMessageMutation) Datetime() (r string, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldDatetime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *UserMessageMutation) ResetDatetime() {
	m.datetime = nil
}

// SetType sets the type field.
func (m *UserMessageMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *UserMessageMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *UserMessageMutation) ResetType() {
	m._type = nil
}

// SetRead sets the read field.
func (m *UserMessageMutation) SetRead(i int) {
	m.read = &i
	m.addread = nil
}

// Read returns the read value in the mutation.
func (m *UserMessageMutation) Read() (r int, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old read value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldRead(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRead is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// AddRead adds i to read.
func (m *UserMessageMutation) AddRead(i int) {
	if m.addread != nil {
		*m.addread += i
	} else {
		m.addread = &i
	}
}

// AddedRead returns the value that was added to the read field in this mutation.
func (m *UserMessageMutation) AddedRead() (r int, exists bool) {
	v := m.addread
	if v == nil {
		return
	}
	return *v, true
}

// ResetRead reset all changes of the "read" field.
func (m *UserMessageMutation) ResetRead() {
	m.read = nil
	m.addread = nil
}

// SetDescription sets the description field.
func (m *UserMessageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *UserMessageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *UserMessageMutation) ResetDescription() {
	m.description = nil
}

// SetClickClose sets the clickClose field.
func (m *UserMessageMutation) SetClickClose(i int) {
	m.clickClose = &i
	m.addclickClose = nil
}

// ClickClose returns the clickClose value in the mutation.
func (m *UserMessageMutation) ClickClose() (r int, exists bool) {
	v := m.clickClose
	if v == nil {
		return
	}
	return *v, true
}

// OldClickClose returns the old clickClose value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldClickClose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClickClose is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClickClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickClose: %w", err)
	}
	return oldValue.ClickClose, nil
}

// AddClickClose adds i to clickClose.
func (m *UserMessageMutation) AddClickClose(i int) {
	if m.addclickClose != nil {
		*m.addclickClose += i
	} else {
		m.addclickClose = &i
	}
}

// AddedClickClose returns the value that was added to the clickClose field in this mutation.
func (m *UserMessageMutation) AddedClickClose() (r int, exists bool) {
	v := m.addclickClose
	if v == nil {
		return
	}
	return *v, true
}

// ResetClickClose reset all changes of the "clickClose" field.
func (m *UserMessageMutation) ResetClickClose() {
	m.clickClose = nil
	m.addclickClose = nil
}

// SetStatus sets the status field.
func (m *UserMessageMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *UserMessageMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *UserMessageMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *UserMessageMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *UserMessageMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreator sets the creator field.
func (m *UserMessageMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *UserMessageMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *UserMessageMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *UserMessageMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *UserMessageMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the UserMessage.
// If the UserMessage object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMessageMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *UserMessageMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *UserMessageMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *UserMessageMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *UserMessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserMessage).
func (m *UserMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMessageMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.uid != nil {
		fields = append(fields, usermessage.FieldUID)
	}
	if m.avatar != nil {
		fields = append(fields, usermessage.FieldAvatar)
	}
	if m.title != nil {
		fields = append(fields, usermessage.FieldTitle)
	}
	if m.datetime != nil {
		fields = append(fields, usermessage.FieldDatetime)
	}
	if m._type != nil {
		fields = append(fields, usermessage.FieldType)
	}
	if m.read != nil {
		fields = append(fields, usermessage.FieldRead)
	}
	if m.description != nil {
		fields = append(fields, usermessage.FieldDescription)
	}
	if m.clickClose != nil {
		fields = append(fields, usermessage.FieldClickClose)
	}
	if m.status != nil {
		fields = append(fields, usermessage.FieldStatus)
	}
	if m.creator != nil {
		fields = append(fields, usermessage.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, usermessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usermessage.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, usermessage.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermessage.FieldUID:
		return m.UID()
	case usermessage.FieldAvatar:
		return m.Avatar()
	case usermessage.FieldTitle:
		return m.Title()
	case usermessage.FieldDatetime:
		return m.Datetime()
	case usermessage.FieldType:
		return m.GetType()
	case usermessage.FieldRead:
		return m.Read()
	case usermessage.FieldDescription:
		return m.Description()
	case usermessage.FieldClickClose:
		return m.ClickClose()
	case usermessage.FieldStatus:
		return m.Status()
	case usermessage.FieldCreator:
		return m.Creator()
	case usermessage.FieldCreatedAt:
		return m.CreatedAt()
	case usermessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case usermessage.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermessage.FieldUID:
		return m.OldUID(ctx)
	case usermessage.FieldAvatar:
		return m.OldAvatar(ctx)
	case usermessage.FieldTitle:
		return m.OldTitle(ctx)
	case usermessage.FieldDatetime:
		return m.OldDatetime(ctx)
	case usermessage.FieldType:
		return m.OldType(ctx)
	case usermessage.FieldRead:
		return m.OldRead(ctx)
	case usermessage.FieldDescription:
		return m.OldDescription(ctx)
	case usermessage.FieldClickClose:
		return m.OldClickClose(ctx)
	case usermessage.FieldStatus:
		return m.OldStatus(ctx)
	case usermessage.FieldCreator:
		return m.OldCreator(ctx)
	case usermessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usermessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usermessage.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown UserMessage field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermessage.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case usermessage.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case usermessage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case usermessage.FieldDatetime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	case usermessage.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usermessage.FieldRead:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case usermessage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case usermessage.FieldClickClose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickClose(v)
		return nil
	case usermessage.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usermessage.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case usermessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usermessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usermessage.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMessageMutation) AddedFields() []string {
	var fields []string
	if m.addread != nil {
		fields = append(fields, usermessage.FieldRead)
	}
	if m.addclickClose != nil {
		fields = append(fields, usermessage.FieldClickClose)
	}
	if m.addstatus != nil {
		fields = append(fields, usermessage.FieldStatus)
	}
	if m.addversion != nil {
		fields = append(fields, usermessage.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usermessage.FieldRead:
		return m.AddedRead()
	case usermessage.FieldClickClose:
		return m.AddedClickClose()
	case usermessage.FieldStatus:
		return m.AddedStatus()
	case usermessage.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usermessage.FieldRead:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRead(v)
		return nil
	case usermessage.FieldClickClose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClickClose(v)
		return nil
	case usermessage.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case usermessage.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMessageMutation) ResetField(name string) error {
	switch name {
	case usermessage.FieldUID:
		m.ResetUID()
		return nil
	case usermessage.FieldAvatar:
		m.ResetAvatar()
		return nil
	case usermessage.FieldTitle:
		m.ResetTitle()
		return nil
	case usermessage.FieldDatetime:
		m.ResetDatetime()
		return nil
	case usermessage.FieldType:
		m.ResetType()
		return nil
	case usermessage.FieldRead:
		m.ResetRead()
		return nil
	case usermessage.FieldDescription:
		m.ResetDescription()
		return nil
	case usermessage.FieldClickClose:
		m.ResetClickClose()
		return nil
	case usermessage.FieldStatus:
		m.ResetStatus()
		return nil
	case usermessage.FieldCreator:
		m.ResetCreator()
		return nil
	case usermessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usermessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usermessage.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown UserMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserMessage unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserMessage edge %s", name)
}

// UserRoleMutation represents an operation that mutate the UserRoles
// nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	role_id       *int
	addrole_id    *int
	expired       *time.Time
	creator       *string
	created_at    *time.Time
	updated_at    *time.Time
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows to manage the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for $n.Name.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the id field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the user_id field.
func (m *UserRoleMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the user_id value in the mutation.
func (m *UserRoleMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to user_id.
func (m *UserRoleMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the user_id field in this mutation.
func (m *UserRoleMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID reset all changes of the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRoleID sets the role_id field.
func (m *UserRoleMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the role_id value in the mutation.
func (m *UserRoleMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old role_id value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to role_id.
func (m *UserRoleMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the role_id field in this mutation.
func (m *UserRoleMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID reset all changes of the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetExpired sets the expired field.
func (m *UserRoleMutation) SetExpired(t time.Time) {
	m.expired = &t
}

// Expired returns the expired value in the mutation.
func (m *UserRoleMutation) Expired() (r time.Time, exists bool) {
	v := m.expired
	if v == nil {
		return
	}
	return *v, true
}

// OldExpired returns the old expired value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpired is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpired: %w", err)
	}
	return oldValue.Expired, nil
}

// ResetExpired reset all changes of the "expired" field.
func (m *UserRoleMutation) ResetExpired() {
	m.expired = nil
}

// SetCreator sets the creator field.
func (m *UserRoleMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the creator value in the mutation.
func (m *UserRoleMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old creator value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator reset all changes of the "creator" field.
func (m *UserRoleMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the version field.
func (m *UserRoleMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the version value in the mutation.
func (m *UserRoleMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the UserRole.
// If the UserRole object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRoleMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to version.
func (m *UserRoleMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the version field in this mutation.
func (m *UserRoleMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion reset all changes of the "version" field.
func (m *UserRoleMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_id != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role_id != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.expired != nil {
		fields = append(fields, userrole.FieldExpired)
	}
	if m.creator != nil {
		fields = append(fields, userrole.FieldCreator)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, userrole.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldExpired:
		return m.Expired()
	case userrole.FieldCreator:
		return m.Creator()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case userrole.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldExpired:
		return m.OldExpired(ctx)
	case userrole.FieldCreator:
		return m.OldCreator(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userrole.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpired(v)
		return nil
	case userrole.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userrole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.addrole_id != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.addversion != nil {
		fields = append(fields, userrole.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserID:
		return m.AddedUserID()
	case userrole.FieldRoleID:
		return m.AddedRoleID()
	case userrole.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case userrole.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldExpired:
		m.ResetExpired()
		return nil
	case userrole.FieldCreator:
		m.ResetCreator()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userrole.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserRole edge %s", name)
}
